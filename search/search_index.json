{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<code>gapper</code> Wiki and API Reference","text":"<p>This is the API reference for <code>gapper</code>, a tool for generating autograders for the GradeScope platform. </p> <p>This tool tries to help create autograders without writing any boilerplate code and save you upload time by uploading your autograder directly to GradeScope.</p>"},{"location":"#questions-tips","title":"Questions? Tips?","text":"<p>Please use the GitHub Discussions forum for any questions, tips, or suggestions you may have!</p>"},{"location":"#showcase","title":"Showcase","text":""},{"location":"#fresh-start","title":"Fresh Start","text":""},{"location":"#upload-with-gui","title":"Upload with GUI","text":""},{"location":"#create-an-assignment-while-uploading","title":"Create An Assignment While Uploading","text":""},{"location":"API/errors/","title":"Errors","text":""},{"location":"API/errors/#api","title":"API","text":"<p>This module contains the error classes used in the framework.</p>"},{"location":"API/errors/#gapper.core.errors.ErrorFormatter","title":"ErrorFormatter","text":"<p>             Bases: <code>Exception</code></p> Source code in <code>src/gapper/core/errors.py</code> <pre><code>class ErrorFormatter(Exception):\n    def extract_user_traceback(self, grader_path: str | None = None) -&gt; List[str]:\n        \"\"\"Extract the user traceback from the exception.\n\n        :param grader_path: The path to the grader file.\n        \"\"\"\n        tbs: List[traceback.FrameSummary] = traceback.extract_tb(self.__traceback__)\n        if grader_path is None:\n            filtered_tbs = filter(lambda tb: \"gapper\" not in tb.filename, tbs)\n        else:\n            filtered_tbs = filter(lambda tb: grader_path not in tb.filename, tbs)\n        return traceback.format_list(list(filtered_tbs))\n\n    def extract_user_traceback_str(\n        self, grader_path: str | None = None, indent_num: int = 0\n    ) -&gt; str:\n        \"\"\"Extract the user traceback from the exception as a string.\"\"\"\n        return indent(\n            \"\\n\".join(self.extract_user_traceback(grader_path)),\n            \" \" * indent_num,\n        )\n\n    def extract_traceback_str(self, indent_num: int = 0) -&gt; str:\n        \"\"\"Extract the traceback from the exception as a string.\"\"\"\n        return indent(\n            \"\\n\".join(traceback.format_tb(self.__traceback__)), \" \" * indent_num\n        )\n\n    def _get_last_tb(self, tb: TracebackType) -&gt; TracebackType:\n        while tb.tb_next is not None:\n            tb = tb.tb_next\n        return tb\n\n    def format_args(self, indent_num: int = 0) -&gt; str:\n        \"\"\"Format the arguments of the error message.\n\n        :param indent_num: The number of spaces to indent the message.\n        \"\"\"\n        return indent(\n            \",\\n\".join(str(arg).rstrip(\"\\n\") for arg in self.args),\n            \" \" * indent_num,\n        )\n\n    def format(self) -&gt; str:\n        \"\"\"Format the error message.\"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"API/errors/#gapper.core.errors.ErrorFormatter.extract_traceback_str","title":"extract_traceback_str","text":"<pre><code>extract_traceback_str(indent_num: int = 0) -&gt; str\n</code></pre> <p>Extract the traceback from the exception as a string.</p> Source code in <code>src/gapper/core/errors.py</code> <pre><code>def extract_traceback_str(self, indent_num: int = 0) -&gt; str:\n    \"\"\"Extract the traceback from the exception as a string.\"\"\"\n    return indent(\n        \"\\n\".join(traceback.format_tb(self.__traceback__)), \" \" * indent_num\n    )\n</code></pre>"},{"location":"API/errors/#gapper.core.errors.ErrorFormatter.extract_user_traceback","title":"extract_user_traceback","text":"<pre><code>extract_user_traceback(grader_path: str | None = None) -&gt; List[str]\n</code></pre> <p>Extract the user traceback from the exception.</p> <p>Parameters:</p> Name Type Description Default <code>grader_path</code> <code>str | None</code> <p>The path to the grader file.</p> <code>None</code> Source code in <code>src/gapper/core/errors.py</code> <pre><code>def extract_user_traceback(self, grader_path: str | None = None) -&gt; List[str]:\n    \"\"\"Extract the user traceback from the exception.\n\n    :param grader_path: The path to the grader file.\n    \"\"\"\n    tbs: List[traceback.FrameSummary] = traceback.extract_tb(self.__traceback__)\n    if grader_path is None:\n        filtered_tbs = filter(lambda tb: \"gapper\" not in tb.filename, tbs)\n    else:\n        filtered_tbs = filter(lambda tb: grader_path not in tb.filename, tbs)\n    return traceback.format_list(list(filtered_tbs))\n</code></pre>"},{"location":"API/errors/#gapper.core.errors.ErrorFormatter.extract_user_traceback_str","title":"extract_user_traceback_str","text":"<pre><code>extract_user_traceback_str(grader_path: str | None = None, indent_num: int = 0) -&gt; str\n</code></pre> <p>Extract the user traceback from the exception as a string.</p> Source code in <code>src/gapper/core/errors.py</code> <pre><code>def extract_user_traceback_str(\n    self, grader_path: str | None = None, indent_num: int = 0\n) -&gt; str:\n    \"\"\"Extract the user traceback from the exception as a string.\"\"\"\n    return indent(\n        \"\\n\".join(self.extract_user_traceback(grader_path)),\n        \" \" * indent_num,\n    )\n</code></pre>"},{"location":"API/errors/#gapper.core.errors.ErrorFormatter.format","title":"format","text":"<pre><code>format() -&gt; str\n</code></pre> <p>Format the error message.</p> Source code in <code>src/gapper/core/errors.py</code> <pre><code>def format(self) -&gt; str:\n    \"\"\"Format the error message.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"API/errors/#gapper.core.errors.ErrorFormatter.format_args","title":"format_args","text":"<pre><code>format_args(indent_num: int = 0) -&gt; str\n</code></pre> <p>Format the arguments of the error message.</p> <p>Parameters:</p> Name Type Description Default <code>indent_num</code> <code>int</code> <p>The number of spaces to indent the message.</p> <code>0</code> Source code in <code>src/gapper/core/errors.py</code> <pre><code>def format_args(self, indent_num: int = 0) -&gt; str:\n    \"\"\"Format the arguments of the error message.\n\n    :param indent_num: The number of spaces to indent the message.\n    \"\"\"\n    return indent(\n        \",\\n\".join(str(arg).rstrip(\"\\n\") for arg in self.args),\n        \" \" * indent_num,\n    )\n</code></pre>"},{"location":"API/errors/#gapper.core.errors.InternalError","title":"InternalError","text":"<p>             Bases: <code>ErrorFormatter</code></p> <p>Raised when an internal error occurs in the framework.</p> Source code in <code>src/gapper/core/errors.py</code> <pre><code>class InternalError(ErrorFormatter):\n    \"\"\"Raised when an internal error occurs in the framework.\"\"\"\n\n    def format(self) -&gt; str:\n        tb_info = indent(\n            tb_str if (tb_str := self.extract_traceback_str()) else \"Not Provided\\n\",\n            \"  \",\n        )\n        return (\n            f\"Internal Error. Please report this to the developers. \\n\"\n            f\"The reason is following: \\n{self.format_args(indent_num=2)}\\n\"\n            f\"Stack Trace: \\n{tb_info}\"\n        )\n</code></pre>"},{"location":"API/errors/#gapper.core.errors.NoSubmissionError","title":"NoSubmissionError","text":"<p>             Bases: <code>StudentError</code></p> <p>Raised when no submission is loaded.</p> Source code in <code>src/gapper/core/errors.py</code> <pre><code>class NoSubmissionError(StudentError):\n    \"\"\"Raised when no submission is loaded.\"\"\"\n\n    def __init__(self, expected_name: str):\n        super().__init__(expected_name)\n\n    @property\n    def expected_name(self) -&gt; str:\n        return self.args[0]\n\n    def format(self) -&gt; str:\n        return (\n            f\"No submission is found.\\n\"\n            f\"If you're submitting a script, please name your submission file as '{self.expected_name}'.\\n\"\n            f\"If you're writing a function or a class, \"\n            f\"please name your submission fn/class as '{self.expected_name}'.\\n\"\n            f\"(without quotes)\\n\"\n        )\n</code></pre>"},{"location":"API/errors/#gapper.core.errors.SubmissionSyntaxError","title":"SubmissionSyntaxError","text":"<p>             Bases: <code>StudentError</code></p> <p>Raised when a submission has syntax errors.</p> Source code in <code>src/gapper/core/errors.py</code> <pre><code>class SubmissionSyntaxError(StudentError):\n    \"\"\"Raised when a submission has syntax errors.\"\"\"\n\n    def format(self) -&gt; str:\n        return (\n            f\"The submission has syntax errors. \"\n            f\"The reason is following: \\n\"\n            f\"{self.format_args(indent_num=2)}\\n\"\n            f\"{self.extract_user_traceback_str()}\"\n        )\n</code></pre>"},{"location":"API/errors/#gapper.core.errors.TestFailedError","title":"TestFailedError","text":"<p>             Bases: <code>ErrorFormatter</code></p> <p>Raised when a test fails.</p> Source code in <code>src/gapper/core/errors.py</code> <pre><code>class TestFailedError(ErrorFormatter):\n    \"\"\"Raised when a test fails.\"\"\"\n\n    def format(self) -&gt; str:\n        return f\"Test Assertion Failed. The reason is following: \\n{self.format_args(indent_num=2)}\\n\"\n</code></pre>"},{"location":"API/gradescope_data_types/","title":"GradeScope Data Types","text":""},{"location":"API/gradescope_data_types/#input-data-types-api","title":"Input Data Types API","text":"<p>The JSON schemas for Gradescope's metadata.</p>"},{"location":"API/gradescope_data_types/#gapper.gradescope.datatypes.gradescope_meta.GradescopeAssignmentMetadata","title":"GradescopeAssignmentMetadata  <code>dataclass</code>","text":"<p>The JSON schema for Gradescope's assignment settings.</p> <p>Parameters:</p> Name Type Description Default <code>due_date</code> <code>datetime</code> <p>The assignment's due date.</p> required <code>group_size</code> <code>Optional[int]</code> <p>The maximum group size on a group assignment.</p> required <code>group_submission</code> <code>bool</code> <p>Whether group submission is allowed.</p> required <code>id</code> <code>int</code> <p>The assignment's ID.</p> required <code>course_id</code> <code>int</code> <p>The course's ID.</p> required <code>late_due_date</code> <code>Optional[datetime]</code> <p>The late due date, or None if late submission disallowed.</p> required <code>release_date</code> <code>datetime</code> <p>The assignment's release date.</p> required <code>title</code> <code>str</code> <p>The assignment's title.</p> required <code>total_points</code> <code>float</code> <p>The total point value of the assignment.</p> required Source code in <code>src/gapper/gradescope/datatypes/gradescope_meta.py</code> <pre><code>@dataclass_json\n@dataclass(frozen=True)\nclass GradescopeAssignmentMetadata:\n    \"\"\"The JSON schema for Gradescope's assignment settings.\n\n    :param due_date: The assignment's due date.\n    :param group_size: The maximum group size on a group assignment.\n    :param group_submission: Whether group submission is allowed.\n    :param id: The assignment's ID.\n    :param course_id: The course's ID.\n    :param late_due_date: The late due date, or None if late submission disallowed.\n    :param release_date: The assignment's release date.\n    :param title: The assignment's title.\n    :param total_points: The total point value of the assignment.\n    \"\"\"\n\n    due_date: datetime = field(\n        metadata=config(\n            encoder=datetime.isoformat,\n            decoder=datetime.fromisoformat,  # type: ignore\n            mm_field=fields.DateTime(format=\"iso\"),\n        )\n    )\n    group_size: Optional[int]\n    group_submission: bool\n    id: int\n    course_id: int\n    late_due_date: Optional[datetime] = field(\n        metadata=config(\n            encoder=lambda s: datetime.isoformat(s) if s else None,\n            decoder=lambda s: datetime.fromisoformat(s) if s else None,  # type: ignore\n            mm_field=fields.DateTime(format=\"iso\"),\n        )\n    )\n    release_date: datetime = field(\n        metadata=config(\n            encoder=datetime.isoformat,\n            decoder=datetime.fromisoformat,  # type: ignore\n            mm_field=fields.DateTime(format=\"iso\"),\n        )\n    )\n    title: str\n    total_points: float = field(metadata=config(encoder=str, decoder=float))\n</code></pre>"},{"location":"API/gradescope_data_types/#gapper.gradescope.datatypes.gradescope_meta.GradescopeAssignmentUser","title":"GradescopeAssignmentUser  <code>dataclass</code>","text":"<p>The JSON schema for a 'user' (submitter) of a Gradescope assignment.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>The submitter's email.</p> required <code>id</code> <code>int</code> <p>The submitter's ID.</p> required <code>name</code> <code>str</code> <p>The submitter's name.</p> required Source code in <code>src/gapper/gradescope/datatypes/gradescope_meta.py</code> <pre><code>@dataclass_json\n@dataclass(frozen=True)\nclass GradescopeAssignmentUser:\n    \"\"\"The JSON schema for a 'user' (submitter) of a Gradescope assignment.\n\n    :param email: The submitter's email.\n    :param id: The submitter's ID.\n    :param name: The submitter's name.\n    \"\"\"\n\n    email: str\n    id: int\n    name: str\n</code></pre>"},{"location":"API/gradescope_data_types/#gapper.gradescope.datatypes.gradescope_meta.GradescopePreviousSubmission","title":"GradescopePreviousSubmission  <code>dataclass</code>","text":"<p>The JSON schema for a previous submission record.</p> <p>Parameters:</p> Name Type Description Default <code>submission_time</code> <code>datetime</code> <p>The time of the previous submission.</p> required <code>score</code> <code>float</code> <p>The previous submission's score.</p> required <code>results</code> <code>GradescopeJson</code> <p>The results.json file from the previous submission.</p> required Source code in <code>src/gapper/gradescope/datatypes/gradescope_meta.py</code> <pre><code>@dataclass_json\n@dataclass(frozen=True)\nclass GradescopePreviousSubmission:\n    \"\"\"The JSON schema for a previous submission record.\n\n    :param submission_time: The time of the previous submission.\n    :param score: The previous submission's score.\n    :param results: The results.json file from the previous submission.\n    \"\"\"\n\n    submission_time: datetime = field(\n        metadata=config(\n            encoder=datetime.isoformat,\n            decoder=datetime.fromisoformat,  # type: ignore\n            mm_field=fields.DateTime(format=\"iso\"),\n        )\n    )\n    score: float\n    results: GradescopeJson\n</code></pre>"},{"location":"API/gradescope_data_types/#gapper.gradescope.datatypes.gradescope_meta.GradescopeSubmissionMetadata","title":"GradescopeSubmissionMetadata  <code>dataclass</code>","text":"<p>The JSON schema for Gradescope's submission metadata.</p> <p>See Also https://gradescope-autograders.readthedocs.io/en/latest/submission_metadata/</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The submission's ID.</p> required <code>created_at</code> <code>datetime</code> <p>The time the submission was created.</p> required <code>assignment</code> <code>GradescopeAssignmentMetadata</code> <p>The assignment's metadata.</p> required <code>submission_method</code> <code>Literal['upload', 'GitHub', 'Bitbucket']</code> <p>The submission method.</p> required <code>users</code> <code>List[GradescopeAssignmentUser]</code> <p>The submitters' metadata.</p> required <code>previous_submissions</code> <code>List[GradescopePreviousSubmission]</code> <p>The previous submissions' metadata.</p> required Source code in <code>src/gapper/gradescope/datatypes/gradescope_meta.py</code> <pre><code>@dataclass_json\n@dataclass(frozen=True)\nclass GradescopeSubmissionMetadata:\n    \"\"\"The JSON schema for Gradescope's submission metadata.\n\n    See Also https://gradescope-autograders.readthedocs.io/en/latest/submission_metadata/\n    :param id: The submission's ID.\n    :param created_at: The time the submission was created.\n    :param assignment: The assignment's metadata.\n    :param submission_method: The submission method.\n    :param users: The submitters' metadata.\n    :param previous_submissions: The previous submissions' metadata.\n    \"\"\"\n\n    id: int\n    created_at: datetime = field(\n        metadata=config(\n            encoder=datetime.isoformat,\n            decoder=datetime.fromisoformat,  # type: ignore\n            mm_field=fields.DateTime(format=\"iso\"),\n        )\n    )\n    assignment: GradescopeAssignmentMetadata\n    submission_method: Literal[\"upload\", \"GitHub\", \"Bitbucket\"]\n    users: List[GradescopeAssignmentUser]\n    previous_submissions: List[GradescopePreviousSubmission]\n\n    @classmethod\n    def from_file(cls, path: Path) -&gt; GradescopeSubmissionMetadata:\n        \"\"\"Load the submission metadata from a file.\n\n        :param path: The path to load the submission metadata from.\n        \"\"\"\n        obj = cls.from_json(path.read_text())  # type: ignore\n        _gradescope_meta_logger.debug(\n            f\"Submission metadata loaded from {path.absolute()}\"\n        )\n        return obj\n</code></pre>"},{"location":"API/gradescope_data_types/#gapper.gradescope.datatypes.gradescope_meta.GradescopeSubmissionMetadata.from_file","title":"from_file  <code>classmethod</code>","text":"<pre><code>from_file(path: Path) -&gt; GradescopeSubmissionMetadata\n</code></pre> <p>Load the submission metadata from a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to load the submission metadata from.</p> required Source code in <code>src/gapper/gradescope/datatypes/gradescope_meta.py</code> <pre><code>@classmethod\ndef from_file(cls, path: Path) -&gt; GradescopeSubmissionMetadata:\n    \"\"\"Load the submission metadata from a file.\n\n    :param path: The path to load the submission metadata from.\n    \"\"\"\n    obj = cls.from_json(path.read_text())  # type: ignore\n    _gradescope_meta_logger.debug(\n        f\"Submission metadata loaded from {path.absolute()}\"\n    )\n    return obj\n</code></pre>"},{"location":"API/gradescope_data_types/#output-data-types-api","title":"Output Data Types API","text":"<p>The Gradescope grading output JSON schema.</p>"},{"location":"API/gradescope_data_types/#gapper.gradescope.datatypes.gradescope_output.GradescopeJson","title":"GradescopeJson  <code>dataclass</code>","text":"<p>The JSON schema for Gradescope.</p> <p>We currently don't support the leaderboard and extra_data features of the gradescope schema. Those are documented on the autograder documentation, here: https://gradescope-autograders.readthedocs.io/en/latest/specs/.</p> <p>Parameters:</p> Name Type Description Default <code>tests</code> <code>list[GradescopeTestJson]</code> <p>The tests for the problem. Required if no global score provided.</p> <code>list()</code> <code>score</code> <code>Optional[float]</code> <p>The overall score. Required if any test has no set score.</p> <code>None</code> <code>execution_time</code> <code>Optional[int]</code> <p>The execution time of all the tests, in seconds.</p> <code>None</code> <code>output</code> <code>Optional[str]</code> <p>The top-level, human-readable text output for all the problems.</p> <code>None</code> <code>visibility</code> <code>VisibilityType</code> <p>The default visibility for each test. Overridden by test-specific settings.</p> <code>'visible'</code> <code>stdout_visibility</code> <code>Optional[str]</code> <p>Whether to show stdout for the tests. Same options as for visibility.</p> <code>None</code> Source code in <code>src/gapper/gradescope/datatypes/gradescope_output.py</code> <pre><code>@dataclass_json\n@dataclass\nclass GradescopeJson:\n    \"\"\"The JSON schema for Gradescope.\n\n    We currently don't support the leaderboard and extra_data features of the gradescope\n    schema. Those are documented on the autograder documentation, here:\n    &lt;https://gradescope-autograders.readthedocs.io/en/latest/specs/&gt;.\n\n    :param tests: The tests for the problem. Required if no global score provided.\n    :param score: The overall score. Required if any test has no set score.\n    :param execution_time: The execution time of all the tests, in seconds.\n    :param output: The top-level, human-readable text output for all the problems.\n    :param visibility: The default visibility for each test. Overridden by test-specific settings.\n    :param stdout_visibility: Whether to show stdout for the tests. Same options as for visibility.\n    \"\"\"\n\n    score: Optional[float] = None\n    tests: list[GradescopeTestJson] = field(default_factory=list)\n    execution_time: Optional[int] = None\n    output: Optional[str] = None\n    visibility: VisibilityType = \"visible\"\n    stdout_visibility: Optional[str] = None\n\n    @classmethod\n    def from_test_results(\n        cls,\n        results: List[TestResult],\n        score: float,\n        save_path: Path | None = None,\n        **kwargs,\n    ) -&gt; GradescopeJson:\n        \"\"\"Convert a list of test results to Gradescope JSON.\n\n        :param results: The test results.\n        :param score: The score obtained from the submission.\n        :param save_path: The path to save the Gradescope JSON to.\n        :param kwargs: The keyword arguments to pass to the constructor.\n        :return: The Gradescope JSON.\n        \"\"\"\n        gs_json = cls(\n            score=score,\n            tests=[GradescopeTestJson.from_test_result(result) for result in results],\n            **kwargs,\n        )\n\n        if save_path is not None:\n            with open(save_path, \"w\") as f:\n                f.write(gs_json.to_json())  # type: ignore\n\n        return gs_json\n\n    @classmethod\n    def from_error(\n        cls, error: InternalError | StudentError, save_path: Path | None = None\n    ) -&gt; GradescopeJson:\n        \"\"\"Convert an error to Gradescope JSON.\n\n        :param error: The error to convert.\n        :param save_path: The path to save the Gradescope JSON to.\n        :return: The Gradescope JSON.\n        \"\"\"\n        gs_json = cls(\n            score=0,\n            tests=[],\n            output=error.format(),\n        )\n\n        if save_path is not None:\n            with open(save_path, \"w\") as f:\n                f.write(gs_json.to_json())  # type: ignore\n\n        return gs_json\n</code></pre>"},{"location":"API/gradescope_data_types/#gapper.gradescope.datatypes.gradescope_output.GradescopeJson.from_error","title":"from_error  <code>classmethod</code>","text":"<pre><code>from_error(error: InternalError | StudentError, save_path: Path | None = None) -&gt; GradescopeJson\n</code></pre> <p>Convert an error to Gradescope JSON.</p> <p>Parameters:</p> Name Type Description Default <code>error</code> <code>InternalError | StudentError</code> <p>The error to convert.</p> required <code>save_path</code> <code>Path | None</code> <p>The path to save the Gradescope JSON to.</p> <code>None</code> <p>Returns:</p> Type Description <code>GradescopeJson</code> <p>The Gradescope JSON.</p> Source code in <code>src/gapper/gradescope/datatypes/gradescope_output.py</code> <pre><code>@classmethod\ndef from_error(\n    cls, error: InternalError | StudentError, save_path: Path | None = None\n) -&gt; GradescopeJson:\n    \"\"\"Convert an error to Gradescope JSON.\n\n    :param error: The error to convert.\n    :param save_path: The path to save the Gradescope JSON to.\n    :return: The Gradescope JSON.\n    \"\"\"\n    gs_json = cls(\n        score=0,\n        tests=[],\n        output=error.format(),\n    )\n\n    if save_path is not None:\n        with open(save_path, \"w\") as f:\n            f.write(gs_json.to_json())  # type: ignore\n\n    return gs_json\n</code></pre>"},{"location":"API/gradescope_data_types/#gapper.gradescope.datatypes.gradescope_output.GradescopeJson.from_test_results","title":"from_test_results  <code>classmethod</code>","text":"<pre><code>from_test_results(results: List[TestResult], score: float, save_path: Path | None = None, **kwargs) -&gt; GradescopeJson\n</code></pre> <p>Convert a list of test results to Gradescope JSON.</p> <p>Parameters:</p> Name Type Description Default <code>results</code> <code>List[TestResult]</code> <p>The test results.</p> required <code>score</code> <code>float</code> <p>The score obtained from the submission.</p> required <code>save_path</code> <code>Path | None</code> <p>The path to save the Gradescope JSON to.</p> <code>None</code> <code>kwargs</code> <p>The keyword arguments to pass to the constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>GradescopeJson</code> <p>The Gradescope JSON.</p> Source code in <code>src/gapper/gradescope/datatypes/gradescope_output.py</code> <pre><code>@classmethod\ndef from_test_results(\n    cls,\n    results: List[TestResult],\n    score: float,\n    save_path: Path | None = None,\n    **kwargs,\n) -&gt; GradescopeJson:\n    \"\"\"Convert a list of test results to Gradescope JSON.\n\n    :param results: The test results.\n    :param score: The score obtained from the submission.\n    :param save_path: The path to save the Gradescope JSON to.\n    :param kwargs: The keyword arguments to pass to the constructor.\n    :return: The Gradescope JSON.\n    \"\"\"\n    gs_json = cls(\n        score=score,\n        tests=[GradescopeTestJson.from_test_result(result) for result in results],\n        **kwargs,\n    )\n\n    if save_path is not None:\n        with open(save_path, \"w\") as f:\n            f.write(gs_json.to_json())  # type: ignore\n\n    return gs_json\n</code></pre>"},{"location":"API/gradescope_data_types/#gapper.gradescope.datatypes.gradescope_output.GradescopeTestJson","title":"GradescopeTestJson  <code>dataclass</code>","text":"<p>The JSON schema for a single Test.</p> <p>Parameters:</p> Name Type Description Default <code>score</code> <code>Optional[float]</code> <p>The test's score. Required if no top-level score is set.</p> <code>None</code> <code>max_score</code> <code>Optional[float]</code> <p>The max score for the test.</p> <code>None</code> <code>name</code> <code>Optional[str]</code> <p>The test's name.</p> <code>None</code> <code>output</code> <code>Optional[str]</code> <p>Human-readable text output of the test.</p> <code>None</code> <code>tags</code> <code>Optional[str]</code> <p>Tags for the test.</p> <code>None</code> <code>visibility</code> <code>VisibilityType</code> <p>The test's visibility. \"hidden\", \"visible\", \"after_due_date\", \"after_published\"</p> <code>'visible'</code> Source code in <code>src/gapper/gradescope/datatypes/gradescope_output.py</code> <pre><code>@dataclass_json\n@dataclass\nclass GradescopeTestJson:\n    \"\"\"The JSON schema for a single Test.\n\n    :param score: The test's score. Required if no top-level score is set.\n    :param max_score: The max score for the test.\n    :param name: The test's name.\n    :param output: Human-readable text output of the test.\n    :param tags: Tags for the test.\n    :param visibility: The test's visibility. \"hidden\", \"visible\", \"after_due_date\", \"after_published\"\n    \"\"\"\n\n    score: Optional[float] = field(default=None)\n    max_score: Optional[float] = field(default=None)\n    status: Optional[PassStateType] = field(default=None)\n    name: Optional[str] = field(default=None)\n    name_format: FormatType = field(default=\"text\")\n    number: Optional[float] = field(default=None)\n    output: Optional[str] = field(default=None)\n    output_format: FormatType = field(default=\"text\")\n    tags: Optional[str] = field(default=None)\n    visibility: VisibilityType = field(default=\"visible\")\n\n    @classmethod\n    def from_test_result(cls, result: TestResult) -&gt; GradescopeTestJson:\n        \"\"\"Convert a test result to Gradescope JSON.\n\n        :param result: The test result to convert.\n        :return: The Gradescope Test JSON.\n        \"\"\"\n        if result.pass_status is None:\n            # even though gradescope says status is optional, setting it to None\n            # will cause an error.\n            raise InternalError(\"pass_status of a test result cannot be None.\")\n\n        return cls(\n            score=result.score,\n            max_score=result.max_score,\n            status=result.pass_status,\n            name=result.rich_test_name,\n            output=result.rich_test_output,\n            visibility=\"hidden\" if result.hidden else \"visible\",\n        )\n</code></pre>"},{"location":"API/gradescope_data_types/#gapper.gradescope.datatypes.gradescope_output.GradescopeTestJson.from_test_result","title":"from_test_result  <code>classmethod</code>","text":"<pre><code>from_test_result(result: TestResult) -&gt; GradescopeTestJson\n</code></pre> <p>Convert a test result to Gradescope JSON.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>TestResult</code> <p>The test result to convert.</p> required <p>Returns:</p> Type Description <code>GradescopeTestJson</code> <p>The Gradescope Test JSON.</p> Source code in <code>src/gapper/gradescope/datatypes/gradescope_output.py</code> <pre><code>@classmethod\ndef from_test_result(cls, result: TestResult) -&gt; GradescopeTestJson:\n    \"\"\"Convert a test result to Gradescope JSON.\n\n    :param result: The test result to convert.\n    :return: The Gradescope Test JSON.\n    \"\"\"\n    if result.pass_status is None:\n        # even though gradescope says status is optional, setting it to None\n        # will cause an error.\n        raise InternalError(\"pass_status of a test result cannot be None.\")\n\n    return cls(\n        score=result.score,\n        max_score=result.max_score,\n        status=result.pass_status,\n        name=result.rich_test_name,\n        output=result.rich_test_output,\n        visibility=\"hidden\" if result.hidden else \"visible\",\n    )\n</code></pre>"},{"location":"API/hook/","title":"<code>HookBase</code> and <code>HookHolder</code>","text":""},{"location":"API/hook/#api","title":"API","text":""},{"location":"API/hook/#gapper.core.hook.HookBase","title":"HookBase","text":"<p>             Bases: <code>ParamExtractor</code></p> Source code in <code>src/gapper/core/hook.py</code> <pre><code>class HookBase[**P, FnType: Callable[P, HookFnReturnType]](ParamExtractor):\n    _hook_type: ClassVar[HookTypes]\n\n    def __init__(\n        self,\n        hook_fn: FnType,\n        as_test_case: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"\n        :param hook_fn: The function when the hook is triggered.\n        :param as_test_case: Whether to treat the post test as a test case.\n            If this is set to True, this hook will incur a TestResult instance to be\n            created and will then be used to synthesize the score. Therefore, it will\n            also be seen as an entry in gradescope.\n\n            If this is set to False, it will only have side effects and will not be seen\n            as an entry in gradescope.\n        :param kwargs: gap keyword parameters.\n        \"\"\"\n        super().__init__(kwargs)\n\n        self.hook_fn = hook_fn\n        self.as_test_case = as_test_case\n        self.hook_fn_res: HookFnReturnType | None = None\n\n    def __call__(self, problem: Problem) -&gt; Problem:\n        \"\"\"Add the post test to the problem.\n\n        :param problem: The problem to add the post test to.\n        \"\"\"\n        problem.add_hook(self, self._hook_type)\n        return problem\n\n    def run[T: HookDataBase](self, data: T) -&gt; TestResult | None:\n        if self.as_test_case and data.result_proxy is None:\n            data.result_proxy = TestResult(self.hook_fn.__name__)\n\n        self._setup_result(data.result_proxy)\n\n        try:\n            self._run(data)\n        except AssertionError as e:\n            data.result_proxy.add_error(\n                TestFailedError(e), set_failed=data.result_proxy.is_pass_status_unset\n            )\n        except Exception as e:\n            data.result_proxy.add_error(\n                InternalError(e), set_failed=data.result_proxy.is_pass_status_unset\n            )\n        else:\n            if data.result_proxy and data.result_proxy.is_pass_status_unset:\n                data.result_proxy.set_pass_status(\"passed\")\n\n        return data.result_proxy\n\n    def _setup_result(self, result: TestResult | None) -&gt; None:\n        if result is None:\n            return\n\n        result.set_name(self.param_info.gap_name)\n        result.set_extra_points(self.param_info.gap_extra_points)\n        if self.param_info.gap_max_score is None and self.param_info.gap_weight is None:\n            result.set_default_weight()\n        else:\n            result.set_max_score(self.param_info.gap_max_score)\n            result.set_weight(self.param_info.gap_weight)\n        result.set_hidden(self.param_info.gap_hidden)\n        if self.param_info.gap_description is not None:\n            result.add_description(\n                *(\n                    [self.param_info.gap_description]\n                    if isinstance(self.param_info.gap_description, str)\n                    else self.param_info.gap_description\n                )\n            )\n\n    def _run(self, *args: P.args, **kwargs: P.kwargs) -&gt; None:\n        self.hook_fn_res = self.hook_fn(*args, **kwargs)\n        self.process_generator()\n\n    def __repr__(self) -&gt; str:\n        return f\"{type(self)}(hook_fn={self.hook_fn}, as_test_case={self.as_test_case}, **{self.param_info})\"\n\n    def process_generator(self) -&gt; None:\n        \"\"\"Process the generator if the hook function returns a generator.\"\"\"\n        if inspect.isgenerator(self.hook_fn_res):\n            try:\n                next(self.hook_fn_res)\n            except Exception as e:\n                raise InternalError(\n                    f\"Facing error running {self._hook_type} hook\"\n                ) from e\n\n    def tear_down(self) -&gt; None:\n        \"\"\"Tear down the generated generator.\"\"\"\n        if inspect.isgenerator(self.hook_fn_res):\n            try:\n                next(self.hook_fn_res)\n            except StopIteration:\n                pass\n            except Exception as e:\n                raise InternalError(\n                    f\"Facing error during {self._hook_type} hook teardown of fn {self.hook_fn.__name__}\"\n                ) from e\n            else:\n                raise InternalError(\n                    f\"Generator not exhausted in the {self._hook_type} of fn {self.hook_fn.__name__}\"\n                )\n</code></pre>"},{"location":"API/hook/#gapper.core.hook.HookBase.__call__","title":"__call__","text":"<pre><code>__call__(problem: Problem) -&gt; Problem\n</code></pre> <p>Add the post test to the problem.</p> <p>Parameters:</p> Name Type Description Default <code>problem</code> <code>Problem</code> <p>The problem to add the post test to.</p> required Source code in <code>src/gapper/core/hook.py</code> <pre><code>def __call__(self, problem: Problem) -&gt; Problem:\n    \"\"\"Add the post test to the problem.\n\n    :param problem: The problem to add the post test to.\n    \"\"\"\n    problem.add_hook(self, self._hook_type)\n    return problem\n</code></pre>"},{"location":"API/hook/#gapper.core.hook.HookBase.__init__","title":"__init__","text":"<pre><code>__init__(hook_fn: FnType, as_test_case: bool = True, **kwargs) -&gt; None\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>hook_fn</code> <code>FnType</code> <p>The function when the hook is triggered.</p> required <code>as_test_case</code> <code>bool</code> <p>Whether to treat the post test as a test case. If this is set to True, this hook will incur a TestResult instance to be created and will then be used to synthesize the score. Therefore, it will also be seen as an entry in gradescope.  If this is set to False, it will only have side effects and will not be seen as an entry in gradescope.</p> <code>True</code> <code>kwargs</code> <p>gap keyword parameters.</p> <code>{}</code> Source code in <code>src/gapper/core/hook.py</code> <pre><code>def __init__(\n    self,\n    hook_fn: FnType,\n    as_test_case: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    :param hook_fn: The function when the hook is triggered.\n    :param as_test_case: Whether to treat the post test as a test case.\n        If this is set to True, this hook will incur a TestResult instance to be\n        created and will then be used to synthesize the score. Therefore, it will\n        also be seen as an entry in gradescope.\n\n        If this is set to False, it will only have side effects and will not be seen\n        as an entry in gradescope.\n    :param kwargs: gap keyword parameters.\n    \"\"\"\n    super().__init__(kwargs)\n\n    self.hook_fn = hook_fn\n    self.as_test_case = as_test_case\n    self.hook_fn_res: HookFnReturnType | None = None\n</code></pre>"},{"location":"API/hook/#gapper.core.hook.HookBase.process_generator","title":"process_generator","text":"<pre><code>process_generator() -&gt; None\n</code></pre> <p>Process the generator if the hook function returns a generator.</p> Source code in <code>src/gapper/core/hook.py</code> <pre><code>def process_generator(self) -&gt; None:\n    \"\"\"Process the generator if the hook function returns a generator.\"\"\"\n    if inspect.isgenerator(self.hook_fn_res):\n        try:\n            next(self.hook_fn_res)\n        except Exception as e:\n            raise InternalError(\n                f\"Facing error running {self._hook_type} hook\"\n            ) from e\n</code></pre>"},{"location":"API/hook/#gapper.core.hook.HookBase.tear_down","title":"tear_down","text":"<pre><code>tear_down() -&gt; None\n</code></pre> <p>Tear down the generated generator.</p> Source code in <code>src/gapper/core/hook.py</code> <pre><code>def tear_down(self) -&gt; None:\n    \"\"\"Tear down the generated generator.\"\"\"\n    if inspect.isgenerator(self.hook_fn_res):\n        try:\n            next(self.hook_fn_res)\n        except StopIteration:\n            pass\n        except Exception as e:\n            raise InternalError(\n                f\"Facing error during {self._hook_type} hook teardown of fn {self.hook_fn.__name__}\"\n            ) from e\n        else:\n            raise InternalError(\n                f\"Generator not exhausted in the {self._hook_type} of fn {self.hook_fn.__name__}\"\n            )\n</code></pre>"},{"location":"API/hook/#gapper.core.hook.HookHolder","title":"HookHolder","text":"Source code in <code>src/gapper/core/hook.py</code> <pre><code>class HookHolder:\n    def __init__(self) -&gt; None:\n        self._hooks: Dict[HookTypes, List[HookBase] | None] = defaultdict(lambda: None)\n\n    def get_or_gen_hooks(self, hook_type: HookTypes) -&gt; List[HookBase]:\n        \"\"\"Get or generate the hooks of the given type. The result is guaranteed to be a list.\n\n        :param hook_type: The type of the hooks.\n        \"\"\"\n        if self.get_hooks(hook_type) is None:\n            self.generate_hooks(hook_type)\n\n        return self._hooks[hook_type]\n\n    def get_hooks(self, hook_type: HookTypes) -&gt; List[HookBase] | None:\n        \"\"\"Get the hooks of the given type.\n\n        :param hook_type: The type of the hooks.\n        \"\"\"\n        return self._hooks[hook_type]\n\n    @abc.abstractmethod\n    def generate_hooks(self, hook_type: HookTypes) -&gt; None:\n        \"\"\"Generate the hooks of the given type.\n\n        :param hook_type: The type of the hooks.\n        \"\"\"\n\n    @abc.abstractmethod\n    def run_hooks(\n        self, hook_type: HookTypes, data: HookDataBase\n    ) -&gt; List[TestResult] | None:\n        \"\"\"Run the hooks of the given type given args and kwargs.\n\n        :param hook_type: The type of the hooks.\n        :param data: The data to be passed to the hooks.\n        \"\"\"\n\n    def tear_down_hooks(self, hook_type: HookTypes) -&gt; None:\n        \"\"\"Tear down the hooks of the given type.\n\n        :param hook_type: The type of the hooks.\n        \"\"\"\n        hooks = self.get_hooks(hook_type)\n        if hooks is None:\n            return\n\n        for hook in hooks:\n            hook.tear_down()\n</code></pre>"},{"location":"API/hook/#gapper.core.hook.HookHolder.generate_hooks","title":"generate_hooks  <code>abstractmethod</code>","text":"<pre><code>generate_hooks(hook_type: HookTypes) -&gt; None\n</code></pre> <p>Generate the hooks of the given type.</p> <p>Parameters:</p> Name Type Description Default <code>hook_type</code> <code>HookTypes</code> <p>The type of the hooks.</p> required Source code in <code>src/gapper/core/hook.py</code> <pre><code>@abc.abstractmethod\ndef generate_hooks(self, hook_type: HookTypes) -&gt; None:\n    \"\"\"Generate the hooks of the given type.\n\n    :param hook_type: The type of the hooks.\n    \"\"\"\n</code></pre>"},{"location":"API/hook/#gapper.core.hook.HookHolder.get_hooks","title":"get_hooks","text":"<pre><code>get_hooks(hook_type: HookTypes) -&gt; List[HookBase] | None\n</code></pre> <p>Get the hooks of the given type.</p> <p>Parameters:</p> Name Type Description Default <code>hook_type</code> <code>HookTypes</code> <p>The type of the hooks.</p> required Source code in <code>src/gapper/core/hook.py</code> <pre><code>def get_hooks(self, hook_type: HookTypes) -&gt; List[HookBase] | None:\n    \"\"\"Get the hooks of the given type.\n\n    :param hook_type: The type of the hooks.\n    \"\"\"\n    return self._hooks[hook_type]\n</code></pre>"},{"location":"API/hook/#gapper.core.hook.HookHolder.get_or_gen_hooks","title":"get_or_gen_hooks","text":"<pre><code>get_or_gen_hooks(hook_type: HookTypes) -&gt; List[HookBase]\n</code></pre> <p>Get or generate the hooks of the given type. The result is guaranteed to be a list.</p> <p>Parameters:</p> Name Type Description Default <code>hook_type</code> <code>HookTypes</code> <p>The type of the hooks.</p> required Source code in <code>src/gapper/core/hook.py</code> <pre><code>def get_or_gen_hooks(self, hook_type: HookTypes) -&gt; List[HookBase]:\n    \"\"\"Get or generate the hooks of the given type. The result is guaranteed to be a list.\n\n    :param hook_type: The type of the hooks.\n    \"\"\"\n    if self.get_hooks(hook_type) is None:\n        self.generate_hooks(hook_type)\n\n    return self._hooks[hook_type]\n</code></pre>"},{"location":"API/hook/#gapper.core.hook.HookHolder.run_hooks","title":"run_hooks  <code>abstractmethod</code>","text":"<pre><code>run_hooks(hook_type: HookTypes, data: HookDataBase) -&gt; List[TestResult] | None\n</code></pre> <p>Run the hooks of the given type given args and kwargs.</p> <p>Parameters:</p> Name Type Description Default <code>hook_type</code> <code>HookTypes</code> <p>The type of the hooks.</p> required <code>data</code> <code>HookDataBase</code> <p>The data to be passed to the hooks.</p> required Source code in <code>src/gapper/core/hook.py</code> <pre><code>@abc.abstractmethod\ndef run_hooks(\n    self, hook_type: HookTypes, data: HookDataBase\n) -&gt; List[TestResult] | None:\n    \"\"\"Run the hooks of the given type given args and kwargs.\n\n    :param hook_type: The type of the hooks.\n    :param data: The data to be passed to the hooks.\n    \"\"\"\n</code></pre>"},{"location":"API/hook/#gapper.core.hook.HookHolder.tear_down_hooks","title":"tear_down_hooks","text":"<pre><code>tear_down_hooks(hook_type: HookTypes) -&gt; None\n</code></pre> <p>Tear down the hooks of the given type.</p> <p>Parameters:</p> Name Type Description Default <code>hook_type</code> <code>HookTypes</code> <p>The type of the hooks.</p> required Source code in <code>src/gapper/core/hook.py</code> <pre><code>def tear_down_hooks(self, hook_type: HookTypes) -&gt; None:\n    \"\"\"Tear down the hooks of the given type.\n\n    :param hook_type: The type of the hooks.\n    \"\"\"\n    hooks = self.get_hooks(hook_type)\n    if hooks is None:\n        return\n\n    for hook in hooks:\n        hook.tear_down()\n</code></pre>"},{"location":"API/hook/#gapper.core.hook.HookTypes","title":"HookTypes","text":"<p>             Bases: <code>Enum</code></p> <p>The types of hooks.</p> Source code in <code>src/gapper/core/hook.py</code> <pre><code>class HookTypes(enum.Enum):\n    \"\"\"The types of hooks.\"\"\"\n\n    PRE_TESTS = \"pre_tests\"\n    POST_TESTS = \"post_tests\"\n    PRE_HOOK = \"pre_hook\"\n    POST_HOOK = \"post_hook\"\n</code></pre>"},{"location":"API/pipeline_support/","title":"Pipeline Support","text":""},{"location":"API/pipeline_support/#api","title":"API","text":"<p>Support for pipeline actions.</p>"},{"location":"API/pipeline_support/#gapper.core.pipeline_support.Constructor","title":"Constructor","text":"<p>             Bases: <code>PipelineFactory</code></p> <p>A pipeline action factory generating init calls.</p> Source code in <code>src/gapper/core/pipeline_support.py</code> <pre><code>class Constructor(PipelineFactory):\n    \"\"\"A pipeline action factory generating __init__ calls.\"\"\"\n\n    class ConstructorEntry(PipelineBase):\n        def __call__(self, obj: Type) -&gt; Any:\n            return obj(*self._args, **self._kwargs)\n\n    ValueType = ConstructorEntry\n\n    def __init__(self) -&gt; None:\n        super().__init__(\"__init__\", _pipeline_replace=True)\n</code></pre>"},{"location":"API/pipeline_support/#gapper.core.pipeline_support.Function","title":"Function","text":"<p>             Bases: <code>PipelineFactory</code></p> <p>A pipeline action factory generating function calls.</p> Source code in <code>src/gapper/core/pipeline_support.py</code> <pre><code>class Function(PipelineFactory):\n    \"\"\"A pipeline action factory generating function calls.\"\"\"\n\n    class FunctionEntry(PipelineBase):\n        def __call__(self, obj: Any) -&gt; Any:\n            \"\"\"Call the function on the object.\"\"\"\n            caller = getattr(obj, self._name, None)\n            if caller is None:\n                raise AttributeError(f\"Object {obj} has no attribute {self._name}.\")\n            return caller(*self._args, **self._kwargs)\n\n    ValueType = FunctionEntry\n</code></pre>"},{"location":"API/pipeline_support/#gapper.core.pipeline_support.Function.FunctionEntry","title":"FunctionEntry","text":"<p>             Bases: <code>PipelineBase</code></p> Source code in <code>src/gapper/core/pipeline_support.py</code> <pre><code>class FunctionEntry(PipelineBase):\n    def __call__(self, obj: Any) -&gt; Any:\n        \"\"\"Call the function on the object.\"\"\"\n        caller = getattr(obj, self._name, None)\n        if caller is None:\n            raise AttributeError(f\"Object {obj} has no attribute {self._name}.\")\n        return caller(*self._args, **self._kwargs)\n</code></pre>"},{"location":"API/pipeline_support/#gapper.core.pipeline_support.Function.FunctionEntry.__call__","title":"__call__","text":"<pre><code>__call__(obj: Any) -&gt; Any\n</code></pre> <p>Call the function on the object.</p> Source code in <code>src/gapper/core/pipeline_support.py</code> <pre><code>def __call__(self, obj: Any) -&gt; Any:\n    \"\"\"Call the function on the object.\"\"\"\n    caller = getattr(obj, self._name, None)\n    if caller is None:\n        raise AttributeError(f\"Object {obj} has no attribute {self._name}.\")\n    return caller(*self._args, **self._kwargs)\n</code></pre>"},{"location":"API/pipeline_support/#gapper.core.pipeline_support.PipelineBase","title":"PipelineBase","text":"<p>A pipeline action base class. All pipeline actions should inherit from this class.</p> Source code in <code>src/gapper/core/pipeline_support.py</code> <pre><code>class PipelineBase:\n    \"\"\"A pipeline action base class. All pipeline actions should inherit from this class.\"\"\"\n\n    def __init__(\n        self, name: str, *args, _pipeline_replace: bool = False, **kwargs\n    ) -&gt; None:\n        \"\"\"A pipeline base class.\n\n        :param name: The name of the attribute to be extracted from the piped object.\n        :param _pipeline_replace: Whether to replace the piped object with the result of the pipeline.\n        :param args: The arguments to pass to the attribute.\n        \"\"\"\n        self._replace = _pipeline_replace\n        self._name = name\n        self._args = args\n        self._kwargs = kwargs\n\n    @property\n    def replace(self) -&gt; bool:\n        \"\"\"Whether to replace the piped object with the result of the pipeline action.\"\"\"\n        return self._replace\n\n    def __call__(self, obj: Any) -&gt; Any:\n        \"\"\"Call the pipeline action on the object.\"\"\"\n        raise NotImplementedError()\n\n    def __repr__(self) -&gt; str:\n        return f\"{self.__class__.__name__}({self._name!r}, {self._args!r}, {self._kwargs!r})\"\n</code></pre>"},{"location":"API/pipeline_support/#gapper.core.pipeline_support.PipelineBase.replace","title":"replace  <code>property</code>","text":"<pre><code>replace: bool\n</code></pre> <p>Whether to replace the piped object with the result of the pipeline action.</p>"},{"location":"API/pipeline_support/#gapper.core.pipeline_support.PipelineBase.__call__","title":"__call__","text":"<pre><code>__call__(obj: Any) -&gt; Any\n</code></pre> <p>Call the pipeline action on the object.</p> Source code in <code>src/gapper/core/pipeline_support.py</code> <pre><code>def __call__(self, obj: Any) -&gt; Any:\n    \"\"\"Call the pipeline action on the object.\"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"API/pipeline_support/#gapper.core.pipeline_support.PipelineBase.__init__","title":"__init__","text":"<pre><code>__init__(name: str, *args, _pipeline_replace: bool = False, **kwargs) -&gt; None\n</code></pre> <p>A pipeline base class.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attribute to be extracted from the piped object.</p> required <code>_pipeline_replace</code> <code>bool</code> <p>Whether to replace the piped object with the result of the pipeline.</p> <code>False</code> <code>args</code> <p>The arguments to pass to the attribute.</p> <code>()</code> Source code in <code>src/gapper/core/pipeline_support.py</code> <pre><code>def __init__(\n    self, name: str, *args, _pipeline_replace: bool = False, **kwargs\n) -&gt; None:\n    \"\"\"A pipeline base class.\n\n    :param name: The name of the attribute to be extracted from the piped object.\n    :param _pipeline_replace: Whether to replace the piped object with the result of the pipeline.\n    :param args: The arguments to pass to the attribute.\n    \"\"\"\n    self._replace = _pipeline_replace\n    self._name = name\n    self._args = args\n    self._kwargs = kwargs\n</code></pre>"},{"location":"API/pipeline_support/#gapper.core.pipeline_support.PipelineFactory","title":"PipelineFactory","text":"<p>A pipeline action factory base class. All pipeline action factories should inherit from this class.</p> <p>The semantics of a pipeline action factory is to generate a pipeline action when called. That is</p> <pre><code>pipeline_factory = PipelineFactory(name)\npipeline_action = pipeline_factory(*args, **kwargs)\n\n@test_case(\n  pipeline_action,\n  pipeline_factory(*args, **kwargs),\n)\n...\n</code></pre> <p>Attributes:</p> Name Type Description <code>ValueType</code> <code>Type[PipelineBase]</code> <p>The type of the pipeline action generated by the factory.</p> Source code in <code>src/gapper/core/pipeline_support.py</code> <pre><code>class PipelineFactory:\n    \"\"\"A pipeline action factory base class. All pipeline action factories should inherit from this class.\n\n    The semantics of a pipeline action factory is to generate a pipeline action when called. That is\n\n        pipeline_factory = PipelineFactory(name)\n        pipeline_action = pipeline_factory(*args, **kwargs)\n\n        @test_case(\n          pipeline_action,\n          pipeline_factory(*args, **kwargs),\n        )\n        ...\n\n    :cvar ValueType: The type of the pipeline action generated by the factory.\n    \"\"\"\n\n    ValueType: ClassVar[Type[PipelineBase]]\n\n    def __init__(self, name: str, *, _pipeline_replace: bool = False) -&gt; None:\n        self._replace = _pipeline_replace\n        self._name = name\n\n    def __call__(self, *args: Any, **kwargs: Any) -&gt; ValueType:  # noqa: F821\n        return type(self).ValueType(\n            self._name, *args, _pipeline_replace=self._replace, **kwargs\n        )\n</code></pre>"},{"location":"API/pipeline_support/#gapper.core.pipeline_support.Property","title":"Property","text":"<p>             Bases: <code>PipelineBase</code></p> <p>A pipeline action factory generating property lookups.</p> Source code in <code>src/gapper/core/pipeline_support.py</code> <pre><code>class Property(PipelineBase):\n    \"\"\"A pipeline action factory generating property lookups.\"\"\"\n\n    def __init__(self, name: str) -&gt; None:\n        \"\"\"Init the pipeline action.\"\"\"\n        super().__init__(name)\n\n    def __call__(self, obj: Any) -&gt; None:\n        \"\"\"Get Property from object.\"\"\"\n        return getattr(obj, self._name)\n</code></pre>"},{"location":"API/pipeline_support/#gapper.core.pipeline_support.Property.__call__","title":"__call__","text":"<pre><code>__call__(obj: Any) -&gt; None\n</code></pre> <p>Get Property from object.</p> Source code in <code>src/gapper/core/pipeline_support.py</code> <pre><code>def __call__(self, obj: Any) -&gt; None:\n    \"\"\"Get Property from object.\"\"\"\n    return getattr(obj, self._name)\n</code></pre>"},{"location":"API/pipeline_support/#gapper.core.pipeline_support.Property.__init__","title":"__init__","text":"<pre><code>__init__(name: str) -&gt; None\n</code></pre> <p>Init the pipeline action.</p> Source code in <code>src/gapper/core/pipeline_support.py</code> <pre><code>def __init__(self, name: str) -&gt; None:\n    \"\"\"Init the pipeline action.\"\"\"\n    super().__init__(name)\n</code></pre>"},{"location":"API/problem/","title":"<code>@problem</code> -- <code>Problem</code>","text":""},{"location":"API/problem/#problem-and-problem-api","title":"<code>Problem</code> And <code>problem</code> API","text":"<p>The module defines the Problem class, which is the abstract representation of a assignment problem.</p>"},{"location":"API/problem/#gapper.core.problem.problem_def.Problem","title":"Problem","text":"<p>             Bases: <code>ModuleLoader</code>, <code>Generic[ProbInputType, ProbOutputType]</code></p> <p>An abstract representation of a assignment problem.</p> Source code in <code>src/gapper/core/problem/problem_def.py</code> <pre><code>class Problem(ModuleLoader, Generic[ProbInputType, ProbOutputType]):\n    \"\"\"An abstract representation of a assignment problem.\"\"\"\n\n    def __init__(\n        self,\n        solution: Callable[ProbInputType, ProbOutputType],\n        *,\n        config: ProblemConfig,\n    ) -&gt; None:\n        \"\"\"Create a problem object.\n\n        :param solution: The solution to the problem.\n        :param config: The configuration of the problem.\n        \"\"\"\n        self._config: ProblemConfig = config\n        self._solution = solution\n        self._test_params: List[TestParam] = []\n        self._hooks: Dict[HookTypes, List[HookBase]] = defaultdict(list)\n        self._logger = _problem_logger.getChild(self.expected_submission_name)\n\n        self._logger.debug(f\"Problem created with config: {self._config}\")\n\n    @property\n    def config(self) -&gt; ProblemConfig:\n        \"\"\"The configuration of the problem.\"\"\"\n        return self._config\n\n    @property\n    def test_cases(self) -&gt; List[TestParam]:\n        \"\"\"The test cases of the problem.\"\"\"\n        return self._test_params\n\n    @property\n    def solution(self) -&gt; Callable[ProbInputType, ProbOutputType]:\n        \"\"\"The solution to the problem.\"\"\"\n        return self._solution\n\n    @property\n    def pre_tests_hooks(self) -&gt; List[PreTests]:\n        \"\"\"The post tests of the problem.\"\"\"\n        return cast(List[PreTests], self._hooks[HookTypes.PRE_TESTS])\n\n    @property\n    def post_tests_hooks(self) -&gt; List[PostTests]:\n        \"\"\"The post tests of the problem.\"\"\"\n        return cast(List[PostTests], self._hooks[HookTypes.POST_TESTS])\n\n    @property\n    def expected_submission_name(self) -&gt; str:\n        \"\"\"The expected name of the submission.\"\"\"\n        return getattr(self.solution, \"__name__\", None) or \"&lt;unnamed_submission&gt;\"\n\n    def add_test_parameter(self, test_param: TestParam) -&gt; None:\n        \"\"\"Add a test parameter to the problem.\n\n        :param test_param: The test parameter to add.\n        \"\"\"\n        self._logger.debug(f\"Adding test parameter {test_param.format()}\")\n        self._test_params.append(test_param)\n\n    def add_hook(self, hook: HookBase, hook_type: HookTypes) -&gt; None:\n        \"\"\"Add a post test to the problem.\n\n        :param hook: The post test to add.\n        :param hook_type: The type of the hook.\n        \"\"\"\n        self._logger.debug(f\"Adding {hook_type.value} hook {hook}\")\n        self._hooks[hook_type].append(hook)\n\n    def __call__(\n        self, *args: ProbInputType.args, **kwargs: ProbInputType.kwargs\n    ) -&gt; ProbOutputType:\n        \"\"\"Run the solution in the problem.\"\"\"\n        return self._solution(*args, **kwargs)\n\n    def generate_tests(self) -&gt; Generator[TestCaseWrapper, None, None]:\n        \"\"\"Generate the test cases.\"\"\"\n        yield from (TestCaseWrapper(param, self) for param in self._test_params)\n\n    @classmethod\n    def _search_problem(cls, path: Path) -&gt; Generator[Problem, None, None]:\n        if path.is_dir():\n            if path.name == \"__pycache__\":\n                _problem_logger.debug(\"Skipping __pycache__ directory\")\n                return\n\n            for sub_path in path.iterdir():\n                yield from cls._search_problem(sub_path)\n        else:\n            if path.suffix != \".py\":\n                _problem_logger.warning(\n                    f\"Skipping {path.absolute()} as it is not a python file\"\n                )\n                return\n\n            spec, mod = cls._load_module_spec_and_module(path, exec_mod=True)\n\n            for val in mod.__dict__.values():\n                if isinstance(val, Problem):\n                    _problem_logger.debug(f\"Found problem {val} in {path.absolute()}\")\n                    yield val\n\n    @classmethod\n    def from_path(cls, path: Path) -&gt; Problem:\n        \"\"\"Load a problem from a path.\n\n        :param path: The path to load the problem from. If the path is a directory, it will be searched recursively.\n                     But only one problem can be defined in a directory.\n        \"\"\"\n        problems = list(cls._search_problem(path))\n        _problem_logger.debug(f\"Found {len(problems)} problems in {path}\")\n\n        if len(problems) == 0:\n            raise NoProblemDefinedError()\n\n        if len(problems) &gt; 1:\n            raise MultipleProblemsDefinedError(\n                prob.expected_submission_name for prob in problems\n            )\n\n        return problems[0]\n</code></pre>"},{"location":"API/problem/#gapper.core.problem.problem_def.Problem.config","title":"config  <code>property</code>","text":"<pre><code>config: ProblemConfig\n</code></pre> <p>The configuration of the problem.</p>"},{"location":"API/problem/#gapper.core.problem.problem_def.Problem.expected_submission_name","title":"expected_submission_name  <code>property</code>","text":"<pre><code>expected_submission_name: str\n</code></pre> <p>The expected name of the submission.</p>"},{"location":"API/problem/#gapper.core.problem.problem_def.Problem.post_tests_hooks","title":"post_tests_hooks  <code>property</code>","text":"<pre><code>post_tests_hooks: List[PostTests]\n</code></pre> <p>The post tests of the problem.</p>"},{"location":"API/problem/#gapper.core.problem.problem_def.Problem.pre_tests_hooks","title":"pre_tests_hooks  <code>property</code>","text":"<pre><code>pre_tests_hooks: List[PreTests]\n</code></pre> <p>The post tests of the problem.</p>"},{"location":"API/problem/#gapper.core.problem.problem_def.Problem.solution","title":"solution  <code>property</code>","text":"<pre><code>solution: Callable[ProbInputType, ProbOutputType]\n</code></pre> <p>The solution to the problem.</p>"},{"location":"API/problem/#gapper.core.problem.problem_def.Problem.test_cases","title":"test_cases  <code>property</code>","text":"<pre><code>test_cases: List[TestParam]\n</code></pre> <p>The test cases of the problem.</p>"},{"location":"API/problem/#gapper.core.problem.problem_def.Problem.__call__","title":"__call__","text":"<pre><code>__call__(*args: ProbInputType.args, **kwargs: ProbInputType.kwargs) -&gt; ProbOutputType\n</code></pre> <p>Run the solution in the problem.</p> Source code in <code>src/gapper/core/problem/problem_def.py</code> <pre><code>def __call__(\n    self, *args: ProbInputType.args, **kwargs: ProbInputType.kwargs\n) -&gt; ProbOutputType:\n    \"\"\"Run the solution in the problem.\"\"\"\n    return self._solution(*args, **kwargs)\n</code></pre>"},{"location":"API/problem/#gapper.core.problem.problem_def.Problem.__init__","title":"__init__","text":"<pre><code>__init__(solution: Callable[ProbInputType, ProbOutputType], *, config: ProblemConfig) -&gt; None\n</code></pre> <p>Create a problem object.</p> <p>Parameters:</p> Name Type Description Default <code>solution</code> <code>Callable[ProbInputType, ProbOutputType]</code> <p>The solution to the problem.</p> required <code>config</code> <code>ProblemConfig</code> <p>The configuration of the problem.</p> required Source code in <code>src/gapper/core/problem/problem_def.py</code> <pre><code>def __init__(\n    self,\n    solution: Callable[ProbInputType, ProbOutputType],\n    *,\n    config: ProblemConfig,\n) -&gt; None:\n    \"\"\"Create a problem object.\n\n    :param solution: The solution to the problem.\n    :param config: The configuration of the problem.\n    \"\"\"\n    self._config: ProblemConfig = config\n    self._solution = solution\n    self._test_params: List[TestParam] = []\n    self._hooks: Dict[HookTypes, List[HookBase]] = defaultdict(list)\n    self._logger = _problem_logger.getChild(self.expected_submission_name)\n\n    self._logger.debug(f\"Problem created with config: {self._config}\")\n</code></pre>"},{"location":"API/problem/#gapper.core.problem.problem_def.Problem.add_hook","title":"add_hook","text":"<pre><code>add_hook(hook: HookBase, hook_type: HookTypes) -&gt; None\n</code></pre> <p>Add a post test to the problem.</p> <p>Parameters:</p> Name Type Description Default <code>hook</code> <code>HookBase</code> <p>The post test to add.</p> required <code>hook_type</code> <code>HookTypes</code> <p>The type of the hook.</p> required Source code in <code>src/gapper/core/problem/problem_def.py</code> <pre><code>def add_hook(self, hook: HookBase, hook_type: HookTypes) -&gt; None:\n    \"\"\"Add a post test to the problem.\n\n    :param hook: The post test to add.\n    :param hook_type: The type of the hook.\n    \"\"\"\n    self._logger.debug(f\"Adding {hook_type.value} hook {hook}\")\n    self._hooks[hook_type].append(hook)\n</code></pre>"},{"location":"API/problem/#gapper.core.problem.problem_def.Problem.add_test_parameter","title":"add_test_parameter","text":"<pre><code>add_test_parameter(test_param: TestParam) -&gt; None\n</code></pre> <p>Add a test parameter to the problem.</p> <p>Parameters:</p> Name Type Description Default <code>test_param</code> <code>TestParam</code> <p>The test parameter to add.</p> required Source code in <code>src/gapper/core/problem/problem_def.py</code> <pre><code>def add_test_parameter(self, test_param: TestParam) -&gt; None:\n    \"\"\"Add a test parameter to the problem.\n\n    :param test_param: The test parameter to add.\n    \"\"\"\n    self._logger.debug(f\"Adding test parameter {test_param.format()}\")\n    self._test_params.append(test_param)\n</code></pre>"},{"location":"API/problem/#gapper.core.problem.problem_def.Problem.from_path","title":"from_path  <code>classmethod</code>","text":"<pre><code>from_path(path: Path) -&gt; Problem\n</code></pre> <p>Load a problem from a path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to load the problem from. If the path is a directory, it will be searched recursively. But only one problem can be defined in a directory.</p> required Source code in <code>src/gapper/core/problem/problem_def.py</code> <pre><code>@classmethod\ndef from_path(cls, path: Path) -&gt; Problem:\n    \"\"\"Load a problem from a path.\n\n    :param path: The path to load the problem from. If the path is a directory, it will be searched recursively.\n                 But only one problem can be defined in a directory.\n    \"\"\"\n    problems = list(cls._search_problem(path))\n    _problem_logger.debug(f\"Found {len(problems)} problems in {path}\")\n\n    if len(problems) == 0:\n        raise NoProblemDefinedError()\n\n    if len(problems) &gt; 1:\n        raise MultipleProblemsDefinedError(\n            prob.expected_submission_name for prob in problems\n        )\n\n    return problems[0]\n</code></pre>"},{"location":"API/problem/#gapper.core.problem.problem_def.Problem.generate_tests","title":"generate_tests","text":"<pre><code>generate_tests() -&gt; Generator[TestCaseWrapper, None, None]\n</code></pre> <p>Generate the test cases.</p> Source code in <code>src/gapper/core/problem/problem_def.py</code> <pre><code>def generate_tests(self) -&gt; Generator[TestCaseWrapper, None, None]:\n    \"\"\"Generate the test cases.\"\"\"\n    yield from (TestCaseWrapper(param, self) for param in self._test_params)\n</code></pre>"},{"location":"API/problem/#gapper.core.problem.problem_def.problem","title":"problem","text":"<pre><code>problem(*, is_script: bool = False, check_stdout: Optional[bool] = None, mock_input: Optional[bool] = None, context: Iterable[str] = (), easy_context: bool = True) -&gt; Callable[[Callable[ProbInputType, ProbOutputType]], Problem[ProbInputType, ProbOutputType]]\n</code></pre> <p>Create a problem object.</p> <p>Parameters:</p> Name Type Description Default <code>is_script</code> <code>bool</code> <p>Whether this problem is a script. This cannot coexist with check_stdout or mock_input.</p> <code>False</code> <code>check_stdout</code> <code>Optional[bool]</code> <p>Whether to check the stdout of the solution.</p> <code>None</code> <code>mock_input</code> <code>Optional[bool]</code> <p>Whether to mock the input of the solution.</p> <code>None</code> <code>context</code> <code>Iterable[str]</code> <p>The context to capture from the submission.</p> <code>()</code> <code>easy_context</code> <code>bool</code> <p>Whether to use context directly in gap override tests.</p> <code>True</code> Source code in <code>src/gapper/core/problem/problem_def.py</code> <pre><code>def problem(\n    *,\n    is_script: bool = False,\n    check_stdout: Optional[bool] = None,\n    mock_input: Optional[bool] = None,\n    context: Iterable[str] = (),\n    easy_context: bool = True,\n) -&gt; Callable[\n    [Callable[ProbInputType, ProbOutputType]],\n    Problem[ProbInputType, ProbOutputType],\n]:\n    \"\"\"Create a problem object.\n\n    :param is_script: Whether this problem is a script. This cannot coexist with check_stdout or mock_input.\n    :param check_stdout: Whether to check the stdout of the solution.\n    :param mock_input: Whether to mock the input of the solution.\n    :param context: The context to capture from the submission.\n    :param easy_context: Whether to use context directly in gap override tests.\n    \"\"\"\n    if is_script:\n        if check_stdout is not None or mock_input is not None:\n            raise ValueError(\"Cannot specify check_stdout or mock_input for a script.\")\n\n        check_stdout, mock_input = True, True\n\n    else:\n        check_stdout = bool(check_stdout) or False\n        mock_input = bool(mock_input) or False\n\n    config = ProblemConfig(\n        check_stdout=check_stdout,\n        mock_input=mock_input,\n        captured_context=context,\n        is_script=is_script,\n        easy_context=easy_context,\n    )\n\n    def _wrapper(\n        fn: Callable[ProbInputType, ProbOutputType]\n    ) -&gt; Problem[ProbInputType, ProbOutputType]:\n        return Problem(fn, config=config)\n\n    return _wrapper\n</code></pre>"},{"location":"API/problem/#problem-configs-api","title":"<code>Problem</code> Configs API","text":"<p>Problem configuration.</p>"},{"location":"API/problem/#gapper.core.problem.problem_config.ProblemConfig","title":"ProblemConfig  <code>dataclass</code>","text":"<p>Problem configuration.</p> <p>Parameters:</p> Name Type Description Default <code>check_stdout</code> <code>bool</code> <p>Whether to check the stdout of the solution.</p> <code>False</code> <code>mock_input</code> <code>bool</code> <p>Whether to mock the input of the solution.</p> <code>False</code> <code>captured_context</code> <code>Iterable[str]</code> <p>The context to capture from the submission.</p> <code>()</code> <code>easy_context</code> <code>bool</code> <p>Whether to use context directly in gap override tests.</p> <code>True</code> <code>is_script</code> <code>bool</code> <p>Whether this problem is a script.</p> <code>False</code> <code>extras</code> <code>ProblemConfigExtra</code> <p>Extra problem configuration dictionary.</p> <code>lambda: defaultdict(None)()</code> Source code in <code>src/gapper/core/problem/problem_config.py</code> <pre><code>@dataclass\nclass ProblemConfig:\n    \"\"\"Problem configuration.\n\n    :param check_stdout: Whether to check the stdout of the solution.\n    :param mock_input: Whether to mock the input of the solution.\n    :param captured_context: The context to capture from the submission.\n    :param easy_context: Whether to use context directly in gap override tests.\n    :param is_script: Whether this problem is a script.\n    :param extras: Extra problem configuration dictionary.\n    \"\"\"\n\n    check_stdout: bool = False\n    mock_input: bool = False\n    captured_context: Iterable[str] = ()\n    easy_context: bool = True\n    is_script: bool = False\n    extras: ProblemConfigExtra = field(default_factory=lambda: defaultdict(None))\n</code></pre>"},{"location":"API/problem/#gapper.core.problem.problem_config.ProblemConfigExtra","title":"ProblemConfigExtra","text":"<p>             Bases: <code>TypedDict</code></p> <p>Extra problem configuration dictionary.</p> Source code in <code>src/gapper/core/problem/problem_config.py</code> <pre><code>class ProblemConfigExtra(TypedDict):\n    \"\"\"Extra problem configuration dictionary.\"\"\"\n\n    gs_connect: Optional[GSConnectConfig]\n</code></pre>"},{"location":"API/problem_extras/","title":"Problem Extras like <code>gs_connect</code>","text":""},{"location":"API/problem_extras/#gradescope-connect-api","title":"Gradescope Connect API","text":"<p>The Gradescope connect decorator and helpers.</p>"},{"location":"API/problem_extras/#gapper.core.problem.extras.gradescope_connect.GSConnectConfig","title":"GSConnectConfig  <code>dataclass</code>","text":"<p>The configuration for Gradescope connect.</p> Source code in <code>src/gapper/core/problem/extras/gradescope_connect.py</code> <pre><code>@dataclass(frozen=True)\nclass GSConnectConfig:\n    \"\"\"The configuration for Gradescope connect.\"\"\"\n\n    cid: str\n    aid: str\n</code></pre>"},{"location":"API/problem_extras/#gapper.core.problem.extras.gradescope_connect.build_connect_config","title":"build_connect_config","text":"<pre><code>build_connect_config(url_or_cid: str, aid: str | None = None) -&gt; GSConnectConfig\n</code></pre> <p>Build the connect arguments.</p> <p>Parameters:</p> Name Type Description Default <code>url_or_cid</code> <code>str</code> <p>The url when aid is not specified, or the course id of the Gradescope assignment. The format of the url should be https://www.gradescope.com/courses//assignments/[anything]  connect('12443', '112358')  # specify cid and aid connect('https://www.gradescope.com/courses/12443/assignments/112358')  # specify url required <code>aid</code> <code>str | None</code> <p>The assignment id of the Gradescope assignment. It should be specified when url_or_cid is a cid.</p> <code>None</code> Source code in <code>src/gapper/core/problem/extras/gradescope_connect.py</code> <pre><code>def build_connect_config(url_or_cid: str, aid: str | None = None) -&gt; GSConnectConfig:\n    \"\"\"Build the connect arguments.\n\n    :param url_or_cid: The url when aid is not specified, or the course id of the Gradescope assignment.\n        The format of the url should be\n        https://www.gradescope.com/courses/&lt;cid&gt;/assignments/&lt;aid&gt;[anything]\n\n                connect('12443', '112358')  # specify cid and aid\n                connect('https://www.gradescope.com/courses/12443/assignments/112358')  # specify url\n\n    :param aid: The assignment id of the Gradescope assignment. It should be specified when url_or_cid is a cid.\n    \"\"\"\n    if aid is None:\n        url = url_or_cid\n        cid, aid = extract_cid_aid_from_url(url)\n        _gs_connect_logger.debug(f\"Extracted cid {cid} and aid {aid} from url {url}\")\n    else:\n        cid = url_or_cid\n        _gs_connect_logger.debug(f\"Using cid {cid} and aid {aid} from user input.\")\n\n    if not cid or not aid:\n        raise ValueError(\n            \"Must specify both cid and aid at the same time. Or specify a url.\"\n        )\n    if (\n        not cid.isdigit() or not aid.isdigit()\n    ):  # not perfect for 0-9 checking but it's fine\n        raise ValueError(\"cid and aid must be digits.\")\n\n    return GSConnectConfig(cid=cid, aid=aid)\n</code></pre>"},{"location":"API/problem_extras/#gapper.core.problem.extras.gradescope_connect.gs_connect","title":"gs_connect","text":"<pre><code>gs_connect(url_or_cid: str, aid: str | None = None) -&gt; Callable[[T], T]\n</code></pre> <p>Connect a problem to a Gradescope assignment.</p> <p>Parameters:</p> Name Type Description Default <code>url_or_cid</code> <code>str</code> <p>The course id of the Gradescope assignment, or the url when aid is not specified. The format of the url should be https://www.gradescope.com/courses//assignments/[anything]  connect('12443', '112358')  # specify cid and aid connect('https://www.gradescope.com/courses/12443/assignments/112358')  # specify url required <code>aid</code> <code>str | None</code> <p>The assignment id of the Gradescope assignment.</p> <code>None</code> Source code in <code>src/gapper/core/problem/extras/gradescope_connect.py</code> <pre><code>def gs_connect[T: Problem](\n    url_or_cid: str,\n    aid: str | None = None,\n) -&gt; Callable[[T], T]:\n    \"\"\"Connect a problem to a Gradescope assignment.\n\n    :param url_or_cid: The course id of the Gradescope assignment, or the url when aid is not specified.\n        The format of the url should be\n        https://www.gradescope.com/courses/&lt;cid&gt;/assignments/&lt;aid&gt;[anything]\n\n            connect('12443', '112358')  # specify cid and aid\n            connect('https://www.gradescope.com/courses/12443/assignments/112358')  # specify url\n\n    :param aid: The assignment id of the Gradescope assignment.\n\n    \"\"\"\n    gs_connect_config = build_connect_config(url_or_cid, aid)\n\n    def _wrapper(prob: T) -&gt; T:\n        prob.config.extras[\"gs_connect\"] = gs_connect_config\n        return prob\n\n    return _wrapper\n</code></pre>"},{"location":"API/result_synthesizer/","title":"<code>ResultSynthesizer</code>","text":""},{"location":"API/result_synthesizer/#api","title":"API","text":"<p>The module contains a class to synthesize the results from a tester.</p>"},{"location":"API/result_synthesizer/#gapper.core.result_synthesizer.ResultSynthesizer","title":"ResultSynthesizer","text":"<p>A class to synthesize the results from a tester.</p> Source code in <code>src/gapper/core/result_synthesizer.py</code> <pre><code>class ResultSynthesizer:\n    \"\"\"A class to synthesize the results from a tester.\"\"\"\n\n    def __init__(\n        self,\n        *,\n        results: List[TestResult] | None = None,\n        metadata: GradescopeSubmissionMetadata | None = None,\n        total_score: float | None = None,\n    ) -&gt; None:\n        \"\"\"Init the result synthesizer.\n\n        :param results: The results of the tester.\n        :param metadata: The metadata of the submission.\n        :param total_score: The total score of the assignment.\n        \"\"\"\n        self._results: List[TestResult] = results or []\n        self._metadata = metadata\n        self._total_score = total_score\n        self._logger = logging.getLogger(\"ResultSynthesizer\")\n        self._logger.debug(\n            f\"ResultSynthesizer created with results with \"\n            f\"total score {total_score}, \"\n            f\"{len(self._results)} tests, \"\n            f\"and metadata {metadata}\"\n        )\n\n    @property\n    def results(self) -&gt; List[TestResult]:\n        \"\"\"The results of the tester.\"\"\"\n        return self._results\n\n    @property\n    def metadata(self):\n        \"\"\"The metadata of the submission.\"\"\"\n        return self._metadata\n\n    @property\n    def total_score(self) -&gt; float:\n        \"\"\"The total score of the assignment.\"\"\"\n        if self._metadata is None and self._total_score is None:\n            raise ValueError(\"metadata and total_score are not set\")\n\n        if self._metadata is not None:\n            return self._metadata.assignment.total_points\n        else:\n            return self._total_score\n\n    @staticmethod\n    def synthesize_score_for(*, results: List[TestResult], total_score: float) -&gt; float:\n        \"\"\"Synthesize the score from the results.\n\n        :param results: The results to synthesize the score from.\n        :param total_score: The total score of the assignment.\n        \"\"\"\n        results_with_score = []\n        results_with_weight = []\n\n        max_score_sum = 0.0\n        weight_sum = 0\n\n        for res in results:\n            if res.max_score is not None and res.weight is not None:\n                raise InternalError(\n                    \"The max_score and weight of a test (result) cannot both be set. \"\n                    f\"But case `{res.rich_test_name}` has both being set. \"\n                    f\"max_score: {res.max_score}, weight: {res.weight}.\"\n                )\n\n            if res.max_score is not None:\n                results_with_score.append(res)\n                max_score_sum += res.max_score\n            elif res.weight is not None:\n                results_with_weight.append(res)\n                weight_sum += res.weight\n            else:\n                raise InternalError(\n                    f\"The max_score and weight of a test (result) cannot both be None. \"\n                    f\"But {res.rich_test_name} has both being None.\"\n                )\n\n        if max_score_sum &gt; total_score:\n            raise InternalError(\n                f\"The sum of the scores ({max_score_sum}) of all tests must be less than or equal to the \"\n                f\"total points for the assignment ({total_score}). This does not apply to the gap_extra_points.\"\n            )\n\n        remaining_score = total_score - max_score_sum\n\n        for res in results_with_weight:\n            assert res.weight is not None\n            res.max_score = res.weight * remaining_score / weight_sum\n            res.weight = None\n\n        for res in results:\n            if res.score is not None:\n                if res.score &lt; 0:\n                    raise InternalError(\n                        f\"Test {res.rich_test_name} has a negative score ({res.score}).\"\n                    )\n\n                if res.is_passed and res.extra_points is not None:\n                    res.score += res.extra_points\n            else:\n                assert (\n                    res.max_score is not None\n                ), f\"TestResult has to have max_score set, but {res.rich_test_name} does not.\"\n\n                # interpret score with pass status\n                if res.pass_status == \"passed\":\n                    res.score = res.max_score + (\n                        0 if res.extra_points is None else res.extra_points\n                    )\n                else:\n                    res.score = 0\n\n        return sum((res.score for res in results), 0.0)\n\n    def synthesize_score(self) -&gt; float:\n        \"\"\"Synthesize the score from the results.\"\"\"\n        return type(self).synthesize_score_for(\n            results=self._results, total_score=self.total_score\n        )\n\n    def to_gradescope_json(\n        self, save_path: Path | None = None, **kwargs\n    ) -&gt; GradescopeJson:\n        \"\"\"Convert the results to Gradescope JSON.\n\n        :param save_path: The path to save the Gradescope JSON to.\n        :param kwargs: The keyword arguments to pass to the GradescopeJson constructor.\n        \"\"\"\n        self._logger.debug(\"Converting results to Gradescope JSON\")\n        score = self.synthesize_score()\n        self._logger.debug(f\"Score obtained: {score} | Total score: {self.total_score}\")\n\n        return GradescopeJson.from_test_results(\n            self._results, score, save_path, **kwargs\n        )\n</code></pre>"},{"location":"API/result_synthesizer/#gapper.core.result_synthesizer.ResultSynthesizer.metadata","title":"metadata  <code>property</code>","text":"<pre><code>metadata\n</code></pre> <p>The metadata of the submission.</p>"},{"location":"API/result_synthesizer/#gapper.core.result_synthesizer.ResultSynthesizer.results","title":"results  <code>property</code>","text":"<pre><code>results: List[TestResult]\n</code></pre> <p>The results of the tester.</p>"},{"location":"API/result_synthesizer/#gapper.core.result_synthesizer.ResultSynthesizer.total_score","title":"total_score  <code>property</code>","text":"<pre><code>total_score: float\n</code></pre> <p>The total score of the assignment.</p>"},{"location":"API/result_synthesizer/#gapper.core.result_synthesizer.ResultSynthesizer.__init__","title":"__init__","text":"<pre><code>__init__(*, results: List[TestResult] | None = None, metadata: GradescopeSubmissionMetadata | None = None, total_score: float | None = None) -&gt; None\n</code></pre> <p>Init the result synthesizer.</p> <p>Parameters:</p> Name Type Description Default <code>results</code> <code>List[TestResult] | None</code> <p>The results of the tester.</p> <code>None</code> <code>metadata</code> <code>GradescopeSubmissionMetadata | None</code> <p>The metadata of the submission.</p> <code>None</code> <code>total_score</code> <code>float | None</code> <p>The total score of the assignment.</p> <code>None</code> Source code in <code>src/gapper/core/result_synthesizer.py</code> <pre><code>def __init__(\n    self,\n    *,\n    results: List[TestResult] | None = None,\n    metadata: GradescopeSubmissionMetadata | None = None,\n    total_score: float | None = None,\n) -&gt; None:\n    \"\"\"Init the result synthesizer.\n\n    :param results: The results of the tester.\n    :param metadata: The metadata of the submission.\n    :param total_score: The total score of the assignment.\n    \"\"\"\n    self._results: List[TestResult] = results or []\n    self._metadata = metadata\n    self._total_score = total_score\n    self._logger = logging.getLogger(\"ResultSynthesizer\")\n    self._logger.debug(\n        f\"ResultSynthesizer created with results with \"\n        f\"total score {total_score}, \"\n        f\"{len(self._results)} tests, \"\n        f\"and metadata {metadata}\"\n    )\n</code></pre>"},{"location":"API/result_synthesizer/#gapper.core.result_synthesizer.ResultSynthesizer.synthesize_score","title":"synthesize_score","text":"<pre><code>synthesize_score() -&gt; float\n</code></pre> <p>Synthesize the score from the results.</p> Source code in <code>src/gapper/core/result_synthesizer.py</code> <pre><code>def synthesize_score(self) -&gt; float:\n    \"\"\"Synthesize the score from the results.\"\"\"\n    return type(self).synthesize_score_for(\n        results=self._results, total_score=self.total_score\n    )\n</code></pre>"},{"location":"API/result_synthesizer/#gapper.core.result_synthesizer.ResultSynthesizer.synthesize_score_for","title":"synthesize_score_for  <code>staticmethod</code>","text":"<pre><code>synthesize_score_for(*, results: List[TestResult], total_score: float) -&gt; float\n</code></pre> <p>Synthesize the score from the results.</p> <p>Parameters:</p> Name Type Description Default <code>results</code> <code>List[TestResult]</code> <p>The results to synthesize the score from.</p> required <code>total_score</code> <code>float</code> <p>The total score of the assignment.</p> required Source code in <code>src/gapper/core/result_synthesizer.py</code> <pre><code>@staticmethod\ndef synthesize_score_for(*, results: List[TestResult], total_score: float) -&gt; float:\n    \"\"\"Synthesize the score from the results.\n\n    :param results: The results to synthesize the score from.\n    :param total_score: The total score of the assignment.\n    \"\"\"\n    results_with_score = []\n    results_with_weight = []\n\n    max_score_sum = 0.0\n    weight_sum = 0\n\n    for res in results:\n        if res.max_score is not None and res.weight is not None:\n            raise InternalError(\n                \"The max_score and weight of a test (result) cannot both be set. \"\n                f\"But case `{res.rich_test_name}` has both being set. \"\n                f\"max_score: {res.max_score}, weight: {res.weight}.\"\n            )\n\n        if res.max_score is not None:\n            results_with_score.append(res)\n            max_score_sum += res.max_score\n        elif res.weight is not None:\n            results_with_weight.append(res)\n            weight_sum += res.weight\n        else:\n            raise InternalError(\n                f\"The max_score and weight of a test (result) cannot both be None. \"\n                f\"But {res.rich_test_name} has both being None.\"\n            )\n\n    if max_score_sum &gt; total_score:\n        raise InternalError(\n            f\"The sum of the scores ({max_score_sum}) of all tests must be less than or equal to the \"\n            f\"total points for the assignment ({total_score}). This does not apply to the gap_extra_points.\"\n        )\n\n    remaining_score = total_score - max_score_sum\n\n    for res in results_with_weight:\n        assert res.weight is not None\n        res.max_score = res.weight * remaining_score / weight_sum\n        res.weight = None\n\n    for res in results:\n        if res.score is not None:\n            if res.score &lt; 0:\n                raise InternalError(\n                    f\"Test {res.rich_test_name} has a negative score ({res.score}).\"\n                )\n\n            if res.is_passed and res.extra_points is not None:\n                res.score += res.extra_points\n        else:\n            assert (\n                res.max_score is not None\n            ), f\"TestResult has to have max_score set, but {res.rich_test_name} does not.\"\n\n            # interpret score with pass status\n            if res.pass_status == \"passed\":\n                res.score = res.max_score + (\n                    0 if res.extra_points is None else res.extra_points\n                )\n            else:\n                res.score = 0\n\n    return sum((res.score for res in results), 0.0)\n</code></pre>"},{"location":"API/result_synthesizer/#gapper.core.result_synthesizer.ResultSynthesizer.to_gradescope_json","title":"to_gradescope_json","text":"<pre><code>to_gradescope_json(save_path: Path | None = None, **kwargs) -&gt; GradescopeJson\n</code></pre> <p>Convert the results to Gradescope JSON.</p> <p>Parameters:</p> Name Type Description Default <code>save_path</code> <code>Path | None</code> <p>The path to save the Gradescope JSON to.</p> <code>None</code> <code>kwargs</code> <p>The keyword arguments to pass to the GradescopeJson constructor.</p> <code>{}</code> Source code in <code>src/gapper/core/result_synthesizer.py</code> <pre><code>def to_gradescope_json(\n    self, save_path: Path | None = None, **kwargs\n) -&gt; GradescopeJson:\n    \"\"\"Convert the results to Gradescope JSON.\n\n    :param save_path: The path to save the Gradescope JSON to.\n    :param kwargs: The keyword arguments to pass to the GradescopeJson constructor.\n    \"\"\"\n    self._logger.debug(\"Converting results to Gradescope JSON\")\n    score = self.synthesize_score()\n    self._logger.debug(f\"Score obtained: {score} | Total score: {self.total_score}\")\n\n    return GradescopeJson.from_test_results(\n        self._results, score, save_path, **kwargs\n    )\n</code></pre>"},{"location":"API/test_case_wrapper/","title":"<code>TestCaseWrapper</code>","text":""},{"location":"API/test_case_wrapper/#api","title":"API","text":""},{"location":"API/test_case_wrapper/#gapper.core.unittest_wrapper.TestCaseWrapper","title":"TestCaseWrapper","text":"<p>             Bases: <code>TestCase</code>, <code>HookHolder</code></p> <p>A wrapper for the unittest.TestCase class.</p> <p>This serves as a proxy for the testing process to get useful information about the test and functions for testing</p> Source code in <code>src/gapper/core/unittest_wrapper/wrapper_def.py</code> <pre><code>class TestCaseWrapper(TestCase, HookHolder):\n    \"\"\"A wrapper for the unittest.TestCase class.\n\n    This serves as a proxy for the testing process to get useful\n    information about the test and functions for testing\n    \"\"\"\n\n    def __init__(self, test_param: TestParam, problem: Problem) -&gt; None:\n        \"\"\"Create a test case wrapper.\n\n        :param test_param: The test parameter to be used in testing.\n        :param problem: The problem definition to be used in testing.\n        \"\"\"\n        TestCase.__init__(self)\n        HookHolder.__init__(self)\n        self._test_param = test_param\n        self._problem = problem\n        self._context: ContextManager | None = None\n        self._metadata: GradescopeSubmissionMetadata | None = None\n        self._logger = _test_wrapper_logger.getChild(self.test_param.format())\n\n    @property\n    def test_param(self) -&gt; TestParam:\n        \"\"\"The test parameter to be used in testing.\"\"\"\n        return self._test_param\n\n    @property\n    def problem(self) -&gt; Problem:\n        \"\"\"The problem definition to be used in testing.\"\"\"\n        return self._problem\n\n    @property\n    def context(self) -&gt; ContextManager | None:\n        \"\"\"The context of the submission.\"\"\"\n        return self._context\n\n    @property\n    def metadata(self) -&gt; GradescopeSubmissionMetadata | None:\n        \"\"\"The metadata of the submission.\"\"\"\n        return self._metadata\n\n    @stdout_cm_adder\n    def _eval_regular[Input](self, to_be_eval: Input, param: TestParam) -&gt; Any:\n        return to_be_eval(*deepcopy(param.args), **deepcopy(param.kwargs))\n\n    @stdout_cm_adder\n    def _eval_mock_input[Input](self, to_be_eval: Input, param: TestParam) -&gt; Any:\n        \"\"\"Evaluate the function with mock input.\"\"\"\n        with patch(\"builtins.input\", generate_custom_input(deepcopy(param.args))):\n            result = to_be_eval()\n\n        return result\n\n    @stdout_cm_adder\n    def _eval_pipeline[Input](self, to_be_eval: Input, param: TestParam) -&gt; Any:\n        \"\"\"Evaluate the pipeline.\"\"\"\n        result = []\n        for i, pipeline_entry in enumerate(param.args):\n            if not isinstance(pipeline_entry, PipelineBase):\n                raise InternalError(f\"The {i}th pipeline entry is not a PipelineBase.\")\n\n            if pipeline_entry.replace:\n                to_be_eval = pipeline_entry(to_be_eval)\n                result.append(None)\n            else:\n                result.append(pipeline_entry(to_be_eval))\n\n        return result\n\n    def _select_eval_fn(self) -&gt; EvalFn:\n        \"\"\"Select the eval function based on the test parameter.\"\"\"\n        if self.problem.config.mock_input:\n            return self._eval_mock_input\n        elif self.test_param.param_info.gap_is_pipeline:\n            return self._eval_pipeline\n        else:\n            return self._eval_regular\n\n    def run_test(self, submission: Any, result: TestResult) -&gt; TestResult:\n        \"\"\"Run the test on the submission.\n\n        :param submission: The submission to be tested.\n        :param result: The result object to be used and written to.\n        :return: The result object passed to this method.\n        \"\"\"\n        self._setup_test_result(result)\n\n        try:\n            self._run_test(submission, result)\n        except AssertionError as e:\n            result.add_error(TestFailedError(e), set_failed=result.is_pass_status_unset)\n        except SyntaxError as e:\n            result.add_error(\n                SubmissionSyntaxError(e), set_failed=result.is_pass_status_unset\n            )\n        except InternalError as e:\n            result.add_error(InternalError(e), set_failed=result.is_pass_status_unset)\n        except Exception as e:\n            result.add_error(StudentError(e), set_failed=result.is_pass_status_unset)\n        else:\n            if result.is_pass_status_unset:\n                result.set_pass_status(\"passed\")\n\n        return result\n\n    def check_test(self) -&gt; Tuple[bool, Any, str] | None:\n        \"\"\"Check if the test passes against the gap_expect and gap_expect_stdout.\n\n        :return: True if the test passes, False if the test fails, None if the test is skipped.\n        \"\"\"\n        self._logger.debug(\"Checking test\")\n        if (\n            self.test_param.param_info.gap_expect is None\n            and self.test_param.param_info.gap_expect_stdout is None\n        ):\n            self._logger.debug(\"Test skipped\")\n            return None\n\n        if self.test_param.param_info.gap_override_test is not None:\n            raise Warning(\"gap_override_test is not None, check_test is ignored.\")\n        else:\n            if self.test_param.param_info.gap_override_check:\n                check_fn: CustomEqualityCheckFn = (\n                    self.test_param.param_info.gap_override_check\n                )\n            else:\n                check_fn = self.assertEqual  # type: ignore\n\n            self._logger.debug(f\"Checking test equality with fn {check_fn.__name__}\")\n\n            eval_fn: EvalFn = self._select_eval_fn()\n\n            self._logger.debug(f\"Selected evaluation fn {eval_fn.__name__}\")\n\n            actual_result, actual_out = eval_fn(self.problem.solution, self.test_param)\n\n            flag = True\n\n            if self.test_param.param_info.gap_expect is not None:\n                try:\n                    check_fn(actual_result, self.test_param.param_info.gap_expect)\n                except AssertionError:\n                    self._logger.debug(\n                        \"Check failed because it does not meet gap_expect\"\n                    )\n                    flag = False\n\n            if self.test_param.param_info.gap_expect_stdout is not None:\n                try:\n                    assert actual_out == self.test_param.param_info.gap_expect_stdout\n                except AssertionError:\n                    self._logger.debug(\n                        \"Check failed because it does not meet gap_expect_stdout\"\n                    )\n                    flag = False\n\n            return flag, actual_result, actual_out\n\n    def _setup_test_result(self, result: TestResult) -&gt; None:\n        \"\"\"Set the test result object to default values specified in the info.\"\"\"\n        result.set_name(self.test_param.param_info.gap_name)\n        result.set_extra_points(self.test_param.param_info.gap_extra_points)\n        if (\n            self.test_param.param_info.gap_max_score is None\n            and self.test_param.param_info.gap_weight is None\n        ):\n            result.set_default_weight()\n        else:\n            result.set_max_score(self.test_param.param_info.gap_max_score)\n            result.set_weight(self.test_param.param_info.gap_weight)\n        result.set_hidden(self.test_param.param_info.gap_hidden)\n        if self.test_param.param_info.gap_description is not None:\n            result.add_description(\n                *(\n                    [self.test_param.param_info.gap_description]\n                    if isinstance(self.test_param.param_info.gap_description, str)\n                    else self.test_param.param_info.gap_description\n                )\n            )\n\n        self._logger.debug(f\"Test result initialized: {result}\")\n\n    def generate_hooks(self, hook_type: HookTypes) -&gt; None:\n        match hook_type:\n            case HookTypes.PRE_HOOK:\n                hook_fns = self.test_param.param_info.gap_pre_hooks\n                hook_wrapper = PreHook\n            case HookTypes.POST_HOOK:\n                hook_fns = self.test_param.param_info.gap_post_hooks\n                hook_wrapper = PostHook\n            case _:\n                raise ValueError(f\"Test Case cannot handle hook {hook_type}\")\n\n        if hook_fns is None:\n            self._hooks[hook_type] = []\n        else:\n            if not isinstance(hook_fns, Sequence):\n                hook_fns: Sequence = [hook_fns]\n\n            self._hooks[hook_type] = [\n                hook_wrapper(self.apply_context(hook_fn)) for hook_fn in hook_fns\n            ]\n\n        self._logger.debug(f\"Generated {hook_type} hooks\")\n\n    def run_hooks(self, hook_type: HookTypes, data) -&gt; None:\n        self._logger.debug(f\"Start running {hook_type} hooks\")\n        for hook in self.get_or_gen_hooks(hook_type):\n            hook.run(data)\n        self._logger.debug(f\"Finished running {hook_type} hooks\")\n\n    def _run_test(self, submission: Any, result: TestResult) -&gt; TestResult:\n        \"\"\"Run the test on the submission.\n\n        :param submission: The submission to be tested.\n        :param result: The result object to be used and written to.\n        \"\"\"\n        self._logger.debug(f\"Running test on submission {submission}\")\n\n        if self.test_param.param_info.gap_override_test is not None:\n            self._logger.debug(\"Handing testing to gap_override_test\")\n            override_test: CustomTestFn = self.apply_context(\n                self.test_param.param_info.gap_override_test\n            )\n            override_test(\n                CustomTestData(self, result, self.problem.solution, submission)\n            )\n        else:\n            eval_fn: EvalFn = self._select_eval_fn()\n            self._logger.debug(f\"Selected evaluation fn {eval_fn.__name__}\")\n\n            self.run_hooks(\n                HookTypes.PRE_HOOK,\n                PreHookData(self, result, self.problem.solution, submission),\n            )\n\n            self._logger.debug(f\"Running test evaluation\")\n            expected = eval_fn(self.problem.solution, self.test_param)\n            actual = eval_fn(submission, self.test_param)\n\n            self.check_results(expected, actual)\n\n            self.run_hooks(\n                HookTypes.POST_HOOK,\n                PostHookData(\n                    self,\n                    result,\n                    self.problem.solution,\n                    submission,\n                    expected,\n                    actual,\n                ),\n            )\n\n            self.tear_down_hooks(HookTypes.PRE_HOOK)\n            self.tear_down_hooks(HookTypes.POST_HOOK)\n\n        self._logger.debug(\"Test completed\")\n\n        return result\n\n    def check_results(self, expected: ResultBundle, actual: ResultBundle) -&gt; None:\n        if self.test_param.param_info.gap_override_check:\n            check_fn: CustomEqualityCheckFn = (\n                self.test_param.param_info.gap_override_check\n            )\n        else:\n            check_fn = self.assertEqual  # type: ignore\n        self._logger.debug(f\"Checking test equality with fn {check_fn.__name__}\")\n\n        check_fn(expected.output, actual.output)\n        if self.problem.config.check_stdout:\n            check_fn(expected.stdout, actual.stdout)\n\n        self._logger.debug(\"Test checked\")\n\n    def apply_context[T: FunctionType](self, fn: T) -&gt; T:\n        if (\n            self.problem.config.easy_context\n            or self.test_param.param_info.gap_easy_context\n        ):\n            self._logger.debug(\"Using easy context\")\n            return apply_context_on_fn(fn, self.context)\n        else:\n            return fn\n\n    def load_context(self, context: ContextManager) -&gt; Self:\n        \"\"\"Load the submission context into the test case.\n\n        :param context: The context to load.\n        \"\"\"\n        self._context = deepcopy(context)\n        self._logger.debug(f\"Context loaded: {self._context}\")\n        return self\n\n    def load_metadata(self, metadata: GradescopeSubmissionMetadata | None) -&gt; Self:\n        \"\"\"Load the submission metadata into the test case.\n\n        :param metadata: The metadata to load. The metadata could be None.\n        \"\"\"\n        self._metadata = metadata\n        self._logger.debug(f\"Metadata loaded: {self._metadata}\")\n        return self\n</code></pre>"},{"location":"API/test_case_wrapper/#gapper.core.unittest_wrapper.TestCaseWrapper.context","title":"context  <code>property</code>","text":"<pre><code>context: ContextManager | None\n</code></pre> <p>The context of the submission.</p>"},{"location":"API/test_case_wrapper/#gapper.core.unittest_wrapper.TestCaseWrapper.metadata","title":"metadata  <code>property</code>","text":"<pre><code>metadata: GradescopeSubmissionMetadata | None\n</code></pre> <p>The metadata of the submission.</p>"},{"location":"API/test_case_wrapper/#gapper.core.unittest_wrapper.TestCaseWrapper.problem","title":"problem  <code>property</code>","text":"<pre><code>problem: Problem\n</code></pre> <p>The problem definition to be used in testing.</p>"},{"location":"API/test_case_wrapper/#gapper.core.unittest_wrapper.TestCaseWrapper.test_param","title":"test_param  <code>property</code>","text":"<pre><code>test_param: TestParam\n</code></pre> <p>The test parameter to be used in testing.</p>"},{"location":"API/test_case_wrapper/#gapper.core.unittest_wrapper.TestCaseWrapper.__init__","title":"__init__","text":"<pre><code>__init__(test_param: TestParam, problem: Problem) -&gt; None\n</code></pre> <p>Create a test case wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>test_param</code> <code>TestParam</code> <p>The test parameter to be used in testing.</p> required <code>problem</code> <code>Problem</code> <p>The problem definition to be used in testing.</p> required Source code in <code>src/gapper/core/unittest_wrapper/wrapper_def.py</code> <pre><code>def __init__(self, test_param: TestParam, problem: Problem) -&gt; None:\n    \"\"\"Create a test case wrapper.\n\n    :param test_param: The test parameter to be used in testing.\n    :param problem: The problem definition to be used in testing.\n    \"\"\"\n    TestCase.__init__(self)\n    HookHolder.__init__(self)\n    self._test_param = test_param\n    self._problem = problem\n    self._context: ContextManager | None = None\n    self._metadata: GradescopeSubmissionMetadata | None = None\n    self._logger = _test_wrapper_logger.getChild(self.test_param.format())\n</code></pre>"},{"location":"API/test_case_wrapper/#gapper.core.unittest_wrapper.TestCaseWrapper.check_test","title":"check_test","text":"<pre><code>check_test() -&gt; Tuple[bool, Any, str] | None\n</code></pre> <p>Check if the test passes against the gap_expect and gap_expect_stdout.</p> <p>Returns:</p> Type Description <code>Tuple[bool, Any, str] | None</code> <p>True if the test passes, False if the test fails, None if the test is skipped.</p> Source code in <code>src/gapper/core/unittest_wrapper/wrapper_def.py</code> <pre><code>def check_test(self) -&gt; Tuple[bool, Any, str] | None:\n    \"\"\"Check if the test passes against the gap_expect and gap_expect_stdout.\n\n    :return: True if the test passes, False if the test fails, None if the test is skipped.\n    \"\"\"\n    self._logger.debug(\"Checking test\")\n    if (\n        self.test_param.param_info.gap_expect is None\n        and self.test_param.param_info.gap_expect_stdout is None\n    ):\n        self._logger.debug(\"Test skipped\")\n        return None\n\n    if self.test_param.param_info.gap_override_test is not None:\n        raise Warning(\"gap_override_test is not None, check_test is ignored.\")\n    else:\n        if self.test_param.param_info.gap_override_check:\n            check_fn: CustomEqualityCheckFn = (\n                self.test_param.param_info.gap_override_check\n            )\n        else:\n            check_fn = self.assertEqual  # type: ignore\n\n        self._logger.debug(f\"Checking test equality with fn {check_fn.__name__}\")\n\n        eval_fn: EvalFn = self._select_eval_fn()\n\n        self._logger.debug(f\"Selected evaluation fn {eval_fn.__name__}\")\n\n        actual_result, actual_out = eval_fn(self.problem.solution, self.test_param)\n\n        flag = True\n\n        if self.test_param.param_info.gap_expect is not None:\n            try:\n                check_fn(actual_result, self.test_param.param_info.gap_expect)\n            except AssertionError:\n                self._logger.debug(\n                    \"Check failed because it does not meet gap_expect\"\n                )\n                flag = False\n\n        if self.test_param.param_info.gap_expect_stdout is not None:\n            try:\n                assert actual_out == self.test_param.param_info.gap_expect_stdout\n            except AssertionError:\n                self._logger.debug(\n                    \"Check failed because it does not meet gap_expect_stdout\"\n                )\n                flag = False\n\n        return flag, actual_result, actual_out\n</code></pre>"},{"location":"API/test_case_wrapper/#gapper.core.unittest_wrapper.TestCaseWrapper.load_context","title":"load_context","text":"<pre><code>load_context(context: ContextManager) -&gt; Self\n</code></pre> <p>Load the submission context into the test case.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>ContextManager</code> <p>The context to load.</p> required Source code in <code>src/gapper/core/unittest_wrapper/wrapper_def.py</code> <pre><code>def load_context(self, context: ContextManager) -&gt; Self:\n    \"\"\"Load the submission context into the test case.\n\n    :param context: The context to load.\n    \"\"\"\n    self._context = deepcopy(context)\n    self._logger.debug(f\"Context loaded: {self._context}\")\n    return self\n</code></pre>"},{"location":"API/test_case_wrapper/#gapper.core.unittest_wrapper.TestCaseWrapper.load_metadata","title":"load_metadata","text":"<pre><code>load_metadata(metadata: GradescopeSubmissionMetadata | None) -&gt; Self\n</code></pre> <p>Load the submission metadata into the test case.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <code>GradescopeSubmissionMetadata | None</code> <p>The metadata to load. The metadata could be None.</p> required Source code in <code>src/gapper/core/unittest_wrapper/wrapper_def.py</code> <pre><code>def load_metadata(self, metadata: GradescopeSubmissionMetadata | None) -&gt; Self:\n    \"\"\"Load the submission metadata into the test case.\n\n    :param metadata: The metadata to load. The metadata could be None.\n    \"\"\"\n    self._metadata = metadata\n    self._logger.debug(f\"Metadata loaded: {self._metadata}\")\n    return self\n</code></pre>"},{"location":"API/test_case_wrapper/#gapper.core.unittest_wrapper.TestCaseWrapper.run_test","title":"run_test","text":"<pre><code>run_test(submission: Any, result: TestResult) -&gt; TestResult\n</code></pre> <p>Run the test on the submission.</p> <p>Parameters:</p> Name Type Description Default <code>submission</code> <code>Any</code> <p>The submission to be tested.</p> required <code>result</code> <code>TestResult</code> <p>The result object to be used and written to.</p> required <p>Returns:</p> Type Description <code>TestResult</code> <p>The result object passed to this method.</p> Source code in <code>src/gapper/core/unittest_wrapper/wrapper_def.py</code> <pre><code>def run_test(self, submission: Any, result: TestResult) -&gt; TestResult:\n    \"\"\"Run the test on the submission.\n\n    :param submission: The submission to be tested.\n    :param result: The result object to be used and written to.\n    :return: The result object passed to this method.\n    \"\"\"\n    self._setup_test_result(result)\n\n    try:\n        self._run_test(submission, result)\n    except AssertionError as e:\n        result.add_error(TestFailedError(e), set_failed=result.is_pass_status_unset)\n    except SyntaxError as e:\n        result.add_error(\n            SubmissionSyntaxError(e), set_failed=result.is_pass_status_unset\n        )\n    except InternalError as e:\n        result.add_error(InternalError(e), set_failed=result.is_pass_status_unset)\n    except Exception as e:\n        result.add_error(StudentError(e), set_failed=result.is_pass_status_unset)\n    else:\n        if result.is_pass_status_unset:\n            result.set_pass_status(\"passed\")\n\n    return result\n</code></pre>"},{"location":"API/test_cases/","title":"@test_case(s) -- <code>TestParam</code> and <code>TestParamBundle</code>,  and <code>gap_*_hooks</code>","text":""},{"location":"API/test_cases/#note","title":"Note","text":"<p><code>test_case</code> and <code>param</code> are aliases of <code>TestParam</code>, and <code>test_cases</code> is a alias of <code>TestParamBundle</code> respectively.</p> <pre><code>from gapper import test_case, param\nfrom gapper.core.test_parameter import TestParam\n\nassert param is TestParam\nassert test_case is TestParam\n</code></pre> <pre><code>from gapper import test_cases\nfrom gapper.core.test_parameter import TestParamBundle\n\nassert test_cases is TestParamBundle\n</code></pre>"},{"location":"API/test_cases/#test_cases-api","title":"<code>test_case(s)</code> API","text":"<p>The module contains the test case (parameter) support classes and functions.</p>"},{"location":"API/test_cases/#gapper.core.test_parameter.ParamExtractor","title":"ParamExtractor","text":"<p>A class to extract the gap test parameter.</p> Source code in <code>src/gapper/core/test_parameter.py</code> <pre><code>class ParamExtractor:\n    \"\"\"A class to extract the gap test parameter.\"\"\"\n\n    def __init__(self, kwargs: Dict[str, Any]) -&gt; None:\n        \"\"\"Initialize the gap test parameter.\"\"\"\n        gap_params = type(self).extra_gap_info(kwargs)\n        self._param_info = type(self)._select_param_info(gap_params)\n\n    @property\n    def param_info(self) -&gt; ParamInfo:\n        \"\"\"Return the parameter information.\"\"\"\n        return self._param_info\n\n    @classmethod\n    def extra_gap_info(\n        cls, kwargs: Dict[str, Any], check_residue: bool = True\n    ) -&gt; Dict[str, Any]:\n        gap_kwargs = {\n            k.value: kwargs.pop(k.value)\n            for k in GapReservedKeywords\n            if k.value in kwargs\n        }\n\n        if check_residue:\n            if caught_residue := cls.check_gap_kwargs_residue(kwargs):\n                raise ValueError(f\"Unknown gap keyword arguments: {caught_residue}\")\n\n        return gap_kwargs\n\n    @staticmethod\n    def _select_param_info(kwargs: Dict[str, Any]) -&gt; ParamInfo:\n        \"\"\"Select the parameter information to fill in.\"\"\"\n        if (\n            kwargs.get(GapReservedKeywords.gap_max_score.value, None) is not None\n            and kwargs.get(GapReservedKeywords.gap_weight.value, None) is not None\n        ):\n            raise ValueError(\"Cannot specify both gap_max_score and gap_weight.\")\n        else:\n            return ParamInfo(**kwargs)\n\n    @staticmethod\n    def check_gap_kwargs_residue(kwargs: Dict[str, Any]) -&gt; List[str]:\n        \"\"\"Check if there are any residue gap kwargs.\n\n        :param kwargs: The keyword arguments to check.\n        \"\"\"\n        caught: List[str] = []\n\n        for kwarg in kwargs.keys():\n            if kwarg.startswith(\"gap_\"):\n                caught.append(kwarg)\n\n        return caught\n\n    def update_gap_kwargs(self, **kwargs: Any) -&gt; None:\n        \"\"\"Update the gap kwargs with a set of kwargs.\n\n        :param kwargs: The keyword arguments to be pushed into the param_info.\n        \"\"\"\n        self._param_info.update(kwargs)\n\n    def __eq__(self, other: ParamExtractor) -&gt; bool:\n        \"\"\"Check if the test parameter is equal to another test parameter.\"\"\"\n        if isinstance(other, ParamExtractor):\n            return self.param_info == other.param_info\n        return False\n</code></pre>"},{"location":"API/test_cases/#gapper.core.test_parameter.ParamExtractor.param_info","title":"param_info  <code>property</code>","text":"<pre><code>param_info: ParamInfo\n</code></pre> <p>Return the parameter information.</p>"},{"location":"API/test_cases/#gapper.core.test_parameter.ParamExtractor.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: ParamExtractor) -&gt; bool\n</code></pre> <p>Check if the test parameter is equal to another test parameter.</p> Source code in <code>src/gapper/core/test_parameter.py</code> <pre><code>def __eq__(self, other: ParamExtractor) -&gt; bool:\n    \"\"\"Check if the test parameter is equal to another test parameter.\"\"\"\n    if isinstance(other, ParamExtractor):\n        return self.param_info == other.param_info\n    return False\n</code></pre>"},{"location":"API/test_cases/#gapper.core.test_parameter.ParamExtractor.__init__","title":"__init__","text":"<pre><code>__init__(kwargs: Dict[str, Any]) -&gt; None\n</code></pre> <p>Initialize the gap test parameter.</p> Source code in <code>src/gapper/core/test_parameter.py</code> <pre><code>def __init__(self, kwargs: Dict[str, Any]) -&gt; None:\n    \"\"\"Initialize the gap test parameter.\"\"\"\n    gap_params = type(self).extra_gap_info(kwargs)\n    self._param_info = type(self)._select_param_info(gap_params)\n</code></pre>"},{"location":"API/test_cases/#gapper.core.test_parameter.ParamExtractor.check_gap_kwargs_residue","title":"check_gap_kwargs_residue  <code>staticmethod</code>","text":"<pre><code>check_gap_kwargs_residue(kwargs: Dict[str, Any]) -&gt; List[str]\n</code></pre> <p>Check if there are any residue gap kwargs.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>Dict[str, Any]</code> <p>The keyword arguments to check.</p> required Source code in <code>src/gapper/core/test_parameter.py</code> <pre><code>@staticmethod\ndef check_gap_kwargs_residue(kwargs: Dict[str, Any]) -&gt; List[str]:\n    \"\"\"Check if there are any residue gap kwargs.\n\n    :param kwargs: The keyword arguments to check.\n    \"\"\"\n    caught: List[str] = []\n\n    for kwarg in kwargs.keys():\n        if kwarg.startswith(\"gap_\"):\n            caught.append(kwarg)\n\n    return caught\n</code></pre>"},{"location":"API/test_cases/#gapper.core.test_parameter.ParamExtractor.update_gap_kwargs","title":"update_gap_kwargs","text":"<pre><code>update_gap_kwargs(**kwargs: Any) -&gt; None\n</code></pre> <p>Update the gap kwargs with a set of kwargs.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>Any</code> <p>The keyword arguments to be pushed into the param_info.</p> <code>{}</code> Source code in <code>src/gapper/core/test_parameter.py</code> <pre><code>def update_gap_kwargs(self, **kwargs: Any) -&gt; None:\n    \"\"\"Update the gap kwargs with a set of kwargs.\n\n    :param kwargs: The keyword arguments to be pushed into the param_info.\n    \"\"\"\n    self._param_info.update(kwargs)\n</code></pre>"},{"location":"API/test_cases/#gapper.core.test_parameter.TestParam","title":"TestParam","text":"<p>             Bases: <code>ParamExtractor</code></p> <p>A class to represent a test case (parameter). Will be used as @test_case() decorator.</p> <p>Attributes:</p> Name Type Description <code>pipeline</code> <code>partial[TestParam]</code> <p>specify test case using pipeline actions.</p> Source code in <code>src/gapper/core/test_parameter.py</code> <pre><code>class TestParam(ParamExtractor):\n    \"\"\"A class to represent a test case (parameter). Will be used as @test_case() decorator.\n\n    :cvar pipeline: specify test case using pipeline actions.\n    \"\"\"\n\n    pipeline: ClassVar[partial[TestParam]]\n    bind = _BoundTestParam\n\n    @overload\n    def __init__(\n        self,\n        *args: Any,\n        gap_expect: Any | None = None,\n        gap_expect_stdout: str | None = None,\n        gap_hidden: bool = False,\n        gap_name: str | None = None,\n        gap_extra_points: float | None = None,\n        gap_override_check: CustomEqualityCheckFn | None = None,\n        gap_easy_context: bool = False,\n        gap_override_test: CustomTestFn | None = None,\n        gap_pre_hooks: List[PreHookFn] | PreHookFn | None = None,\n        gap_post_hooks: List[PostHookFn] | PostHookFn | None = None,\n        gap_description: str | Iterable[str] | None = None,\n        gap_is_pipeline: bool = False,\n        gap_max_score: float | None = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Initialize the gap test parameter (test_case).\n\n        :param args: The arguments for the test parameter.\n        :param gap_expect: The expected output of the test case.\n        :param gap_expect_stdout: The expected stdout of the test case.\n        :param gap_hidden: Whether the test case is hidden.\n        :param gap_name: The name of the test case.\n        :param gap_extra_points: The extra credit of the test case.\n        :param gap_override_check: The custom equality check function.\n        :param gap_easy_context: Whether to use context directly in gap override tests.\n        :param gap_override_test: The custom test function.\n        :param gap_pre_hooks: The custom functions run before tests.\n        :param gap_post_hooks: The custom functions run after tests.\n        :param gap_description: The description of the test case.\n        :param gap_is_pipeline: Whether the test case is a pipeline.\n        :param gap_max_score: The max score of the test case. This and gap_weight cannot be specified as the same ti\n        :param kwargs: The keyword arguments for the test parameter, including kwargs.\n        \"\"\"\n\n    @overload\n    def __init__(\n        self,\n        *args: Any,\n        gap_expect: Any | None = None,\n        gap_expect_stdout: str | None = None,\n        gap_hidden: bool = False,\n        gap_name: str | None = None,\n        gap_extra_points: float | None = None,\n        gap_override_check: CustomEqualityCheckFn | None = None,\n        gap_easy_context: bool = False,\n        gap_override_test: CustomTestFn | None = None,\n        gap_pre_hooks: List[PreHookFn] | PreHookFn | None = None,\n        gap_post_hooks: List[PostHookFn] | PostHookFn | None = None,\n        gap_description: str | Iterable[str] | None = None,\n        gap_is_pipeline: bool = False,\n        gap_weight: float | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Initialize the gap test parameter (test_case).\n\n        :param args: The arguments for the test parameter.\n        :param gap_expect: The expected output of the test case.\n        :param gap_expect_stdout: The expected stdout of the test case.\n        :param gap_hidden: Whether the test case is hidden.\n        :param gap_name: The name of the test case.\n        :param gap_extra_points: The extra credit of the test case.\n        :param gap_override_check: The custom equality check function.\n        :param gap_easy_context: Whether to use context directly in gap override tests.\n        :param gap_override_test: The custom test function.\n        :param gap_pre_hooks: The custom functions run before tests.\n        :param gap_post_hooks: The custom functions run after tests.\n        :param gap_description: The description of the test case.\n        :param gap_is_pipeline: Whether the test case is a pipeline.\n        :param gap_weight: The weight of the test case. This and gap_max_score cannot be specified as the same time.\n        :param kwargs: The keyword arguments for the test parameter, including kwargs.\n        \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -&gt; None:\n        \"\"\"Initialize the gap test parameter (test_case).\n\n        :param args: The arguments for the test parameter.\n        :param kwargs: The keyword arguments for the test parameter, including kwargs.\n        \"\"\"\n        super().__init__(kwargs)\n        self._args = args\n        self._kwargs = kwargs\n\n    def __call__[T: Problem[ProbInputType, ProbOutputType]](self, prob: T) -&gt; T:\n        \"\"\"Make itself to be a decorator.\"\"\"\n        return self.register_test_param(prob)\n\n    def register_test_param[T: Problem[ProbInputType, ProbOutputType]](\n        self, prob: T\n    ) -&gt; T:\n        \"\"\"Register the test parameter to the problem.\"\"\"\n        prob.add_test_parameter(self)\n        return prob\n\n    @property\n    def args(self) -&gt; tuple[Any, ...]:\n        \"\"\"Return the arguments of the test parameter.\"\"\"\n        return self._args\n\n    @args.setter\n    def args(self, args: tuple[Any, ...]) -&gt; None:\n        \"\"\"Set the arguments of the test parameter.\"\"\"\n        self._args = args\n\n    @property\n    def kwargs(self) -&gt; dict[str, Any]:\n        \"\"\"Return the keyword arguments of the test parameter.\"\"\"\n        return self._kwargs\n\n    @kwargs.setter\n    def kwargs(self, kwargs: dict[str, Any]) -&gt; None:\n        \"\"\"Set the keyword arguments of the test parameter.\"\"\"\n        self._kwargs = kwargs\n\n    def format(self, with_gap_kwargs: bool = False) -&gt; str:\n        \"\"\"Format the test parameter.\"\"\"\n        args = self.args\n\n        if with_gap_kwargs:\n            kwargs = {**self.kwargs, **asdict(self.param_info)}\n        else:\n            kwargs = self.kwargs\n\n        args_format = \", \".join(str(arg) for arg in args)\n        kwargs_format = \", \".join(f\"{kwarg}={value}\" for kwarg, value in kwargs.items())\n\n        if args_format:\n            if kwargs_format:\n                return f\"({args_format}, {kwargs_format})\"\n            else:\n                return f\"({args_format})\"\n        else:\n            return f\"({kwargs_format})\"\n\n    def __eq__(self, other: TestParam) -&gt; bool:\n        \"\"\"Check if the test parameter is equal to another test parameter.\n\n        Two test parameters are equal if their args, kwargs, and params_info are equal.\n\n        :param other: The other test parameter to compare with.\n        \"\"\"\n        if isinstance(other, TestParam):\n            return (\n                self.args == other.args\n                and self.kwargs == other.kwargs\n                and super().__eq__(other)\n            )\n\n        return False\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return the representation of the test parameter.\"\"\"\n        return f\"param{self.format(with_gap_kwargs=True)}\"\n</code></pre>"},{"location":"API/test_cases/#gapper.core.test_parameter.TestParam.args","title":"args  <code>property</code> <code>writable</code>","text":"<pre><code>args: tuple[Any, ...]\n</code></pre> <p>Return the arguments of the test parameter.</p>"},{"location":"API/test_cases/#gapper.core.test_parameter.TestParam.kwargs","title":"kwargs  <code>property</code> <code>writable</code>","text":"<pre><code>kwargs: dict[str, Any]\n</code></pre> <p>Return the keyword arguments of the test parameter.</p>"},{"location":"API/test_cases/#gapper.core.test_parameter.TestParam.__call__","title":"__call__","text":"<pre><code>__call__(prob: T) -&gt; T\n</code></pre> <p>Make itself to be a decorator.</p> Source code in <code>src/gapper/core/test_parameter.py</code> <pre><code>def __call__[T: Problem[ProbInputType, ProbOutputType]](self, prob: T) -&gt; T:\n    \"\"\"Make itself to be a decorator.\"\"\"\n    return self.register_test_param(prob)\n</code></pre>"},{"location":"API/test_cases/#gapper.core.test_parameter.TestParam.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: TestParam) -&gt; bool\n</code></pre> <p>Check if the test parameter is equal to another test parameter.</p> <p>Two test parameters are equal if their args, kwargs, and params_info are equal.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>TestParam</code> <p>The other test parameter to compare with.</p> required Source code in <code>src/gapper/core/test_parameter.py</code> <pre><code>def __eq__(self, other: TestParam) -&gt; bool:\n    \"\"\"Check if the test parameter is equal to another test parameter.\n\n    Two test parameters are equal if their args, kwargs, and params_info are equal.\n\n    :param other: The other test parameter to compare with.\n    \"\"\"\n    if isinstance(other, TestParam):\n        return (\n            self.args == other.args\n            and self.kwargs == other.kwargs\n            and super().__eq__(other)\n        )\n\n    return False\n</code></pre>"},{"location":"API/test_cases/#gapper.core.test_parameter.TestParam.__init__","title":"__init__","text":"<pre><code>__init__(*args: Any, **kwargs: Any) -&gt; None\n</code></pre> <p>Initialize the gap test parameter (test_case).</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Any</code> <p>The arguments for the test parameter.</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>The keyword arguments for the test parameter, including kwargs.</p> <code>{}</code> Source code in <code>src/gapper/core/test_parameter.py</code> <pre><code>def __init__(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Initialize the gap test parameter (test_case).\n\n    :param args: The arguments for the test parameter.\n    :param kwargs: The keyword arguments for the test parameter, including kwargs.\n    \"\"\"\n    super().__init__(kwargs)\n    self._args = args\n    self._kwargs = kwargs\n</code></pre>"},{"location":"API/test_cases/#gapper.core.test_parameter.TestParam.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return the representation of the test parameter.</p> Source code in <code>src/gapper/core/test_parameter.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return the representation of the test parameter.\"\"\"\n    return f\"param{self.format(with_gap_kwargs=True)}\"\n</code></pre>"},{"location":"API/test_cases/#gapper.core.test_parameter.TestParam.format","title":"format","text":"<pre><code>format(with_gap_kwargs: bool = False) -&gt; str\n</code></pre> <p>Format the test parameter.</p> Source code in <code>src/gapper/core/test_parameter.py</code> <pre><code>def format(self, with_gap_kwargs: bool = False) -&gt; str:\n    \"\"\"Format the test parameter.\"\"\"\n    args = self.args\n\n    if with_gap_kwargs:\n        kwargs = {**self.kwargs, **asdict(self.param_info)}\n    else:\n        kwargs = self.kwargs\n\n    args_format = \", \".join(str(arg) for arg in args)\n    kwargs_format = \", \".join(f\"{kwarg}={value}\" for kwarg, value in kwargs.items())\n\n    if args_format:\n        if kwargs_format:\n            return f\"({args_format}, {kwargs_format})\"\n        else:\n            return f\"({args_format})\"\n    else:\n        return f\"({kwargs_format})\"\n</code></pre>"},{"location":"API/test_cases/#gapper.core.test_parameter.TestParam.register_test_param","title":"register_test_param","text":"<pre><code>register_test_param(prob: T) -&gt; T\n</code></pre> <p>Register the test parameter to the problem.</p> Source code in <code>src/gapper/core/test_parameter.py</code> <pre><code>def register_test_param[T: Problem[ProbInputType, ProbOutputType]](\n    self, prob: T\n) -&gt; T:\n    \"\"\"Register the test parameter to the problem.\"\"\"\n    prob.add_test_parameter(self)\n    return prob\n</code></pre>"},{"location":"API/test_cases/#gapper.core.test_parameter.TestParamBundle","title":"TestParamBundle","text":"<p>A class to represent a test parameter bundle (test_cases). Will be used as @test_cases() decorator.</p> <p>Attributes:</p> Name Type Description <code>params</code> <code>partial[TestParamBundle]</code> <p>specify test cases using parameters.</p> <code>param_iter</code> <code>partial[TestParamBundle]</code> <p>specify test cases using parameter iterators.</p> <code>singular_params</code> <code>partial[TestParamBundle]</code> <p>specify test cases using singular parameters.</p> <code>singular_param_iter</code> <code>partial[TestParamBundle]</code> <p>specify test cases using singular parameter iterators.</p> <code>zip</code> <code>partial[TestParamBundle]</code> <p>specify test cases using zip.</p> <code>product</code> <code>partial[TestParamBundle]</code> <p>specify test cases using product.</p> Source code in <code>src/gapper/core/test_parameter.py</code> <pre><code>class TestParamBundle:\n    \"\"\"A class to represent a test parameter bundle (test_cases). Will be used as @test_cases() decorator.\n\n    :cvar params: specify test cases using parameters.\n    :cvar param_iter: specify test cases using parameter iterators.\n    :cvar singular_params: specify test cases using singular parameters.\n    :cvar singular_param_iter: specify test cases using singular parameter iterators.\n    :cvar zip: specify test cases using zip.\n    :cvar product: specify test cases using product.\n    \"\"\"\n\n    params: ClassVar[partial[TestParamBundle]]\n    param_iter: ClassVar[partial[TestParamBundle]]\n    zip: ClassVar[partial[TestParamBundle]]\n    product: ClassVar[partial[TestParamBundle]]\n    singular_params: ClassVar[partial[TestParamBundle]]\n    singular_param_iter: ClassVar[partial[TestParamBundle]]\n\n    bind = _BoundTestParamBundle\n\n    @overload\n    def __init__(\n        self,\n        *args: Any,\n        gap_expect: Any | Sequence[Any] | None = None,\n        gap_expect_stdout: str | Sequence[str] | None = None,\n        gap_hidden: bool | Sequence[bool] = False,\n        gap_name: str | Sequence[str] | None = None,\n        gap_extra_points: float | Sequence[float] | None = None,\n        gap_override_check: CustomEqualityCheckFn\n        | Sequence[CustomEqualityCheckFn]\n        | None = None,\n        gap_easy_context: bool | Sequence[bool] = False,\n        gap_override_test: CustomTestFn | Sequence[CustomTestFn] | None = None,\n        gap_post_hooks: List[List[PostHookFn]]\n        | List[PostHookFn]\n        | PostHookFn\n        | None = None,\n        gap_pre_hooks: List[List[PreHookFn]]\n        | List[PreHookFn]\n        | PreHookFn\n        | None = None,\n        gap_description: str | Iterable[str] | Sequence[Iterable[str]] | None = None,\n        gap_is_pipeline: bool | Sequence[bool] = False,\n        gap_max_score: float | Sequence[float] | None = None,\n        gap_params: bool = False,\n        gap_param_iter: bool = False,\n        gap_singular_params: bool = False,\n        gap_singular_param_iter: bool = False,\n        **kwargs,\n    ) -&gt; None:\n        ...\n\n    @overload\n    def __init__(\n        self,\n        *args: Any,\n        gap_expect: Any | Sequence[Any] | None = None,\n        gap_expect_stdout: str | Sequence[str] | None = None,\n        gap_hidden: bool | Sequence[bool] = False,\n        gap_name: str | Sequence[str] | None = None,\n        gap_extra_points: float | Sequence[float] | None = None,\n        gap_override_check: CustomEqualityCheckFn\n        | Sequence[CustomEqualityCheckFn]\n        | None = None,\n        gap_easy_context: bool | Sequence[bool] = False,\n        gap_override_test: CustomTestFn | Sequence[CustomTestFn] | None = None,\n        gap_pre_hooks: List[List[PreHookFn]]\n        | List[PreHookFn]\n        | PreHookFn\n        | None = None,\n        gap_post_hooks: List[List[PostHookFn]]\n        | List[PostHookFn]\n        | PostHookFn\n        | None = None,\n        gap_description: str | Iterable[str] | Sequence[Iterable[str]] | None = None,\n        gap_is_pipeline: bool | Sequence[bool] = False,\n        gap_weight: float | Sequence[float] | None = None,\n        gap_params: bool = False,\n        gap_param_iter: bool = False,\n        gap_singular_params: bool = False,\n        gap_singular_param_iter: bool = False,\n        **kwargs: Any,\n    ) -&gt; None:\n        ...\n\n    def __init__(\n        self,\n        *args: Iterable[Any] | Any,\n        gap_product: bool = False,\n        gap_zip: bool = False,\n        gap_params: bool = False,\n        gap_param_iter: bool = False,\n        gap_singular_params: bool = False,\n        gap_singular_param_iter: bool = False,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Initialize the test parameter bundle (test_cases).\n\n        :param args: The arguments for the test parameter bundle.\n        :param gap_product: Whether to take the cartesian product of the arguments.\n            .. deprecated::\n                Use params, param_iter, singular_params, singular_param_iter instead.\n        :param gap_zip: Whether to zip the arguments.\n            .. deprecated::\n                Use params, param_iter, singular_params, singular_param_iter instead.\n        :param gap_params: Whether to parse the arguments as parameters.\n        :param gap_param_iter: Whether to parse the argument as parameter iterators.\n        :param gap_singular_params: Whether to parse the arguments as singular parameters.\n        :param gap_singular_param_iter: Whether to parse the arguments as singular parameter iterators.\n        :param kwargs: The keyword arguments for the test parameter bundle.\n            .. seealso::\n                :class:`gapper.core.test_parameter.TestParam`\n            .. seealso::\n                :class:`gapper.core.test_parameter.ParamExtractor`\n        \"\"\"\n        if (\n            gap_params\n            + gap_param_iter\n            + gap_zip\n            + gap_product\n            + gap_singular_params\n            + gap_singular_param_iter\n        ) != 1:\n            raise ValueError(\n                \"Exactly many of gap_product, gap_zip, or gap_params are True. \"\n                \"Only 1 of the flags is allowed. \\n\"\n                f\"You got: \"\n                f\"gap_product={gap_product}, gap_zip={gap_zip}, \"\n                f\"gap_params={gap_params}, gap_singular_params={gap_singular_params}\"\n            )\n\n        if gap_product:\n            raise warnings.warn(\"gap_product is deprecated.\")\n        if gap_zip:\n            raise warnings.warn(\"gap_zip is deprecated.\")\n\n        # pop gap keywords out\n        gap_kwargs_dict = ParamExtractor.extra_gap_info(kwargs)\n\n        if gap_params:\n            self.final_params: List[TestParam] = type(self).parse_params(\n                *args, **kwargs\n            )\n        elif gap_param_iter:\n            self.final_params = type(self).parse_param_iter(*args, **kwargs)\n        elif gap_singular_params:\n            self.final_params = type(self).parse_singular_params(*args, **kwargs)\n        elif gap_singular_param_iter:\n            self.final_params = type(self).parse_singular_param_iter(*args, **kwargs)\n        elif gap_zip or gap_product:\n            self.final_params = type(self).parse_zip_or_product(\n                *args, gap_zip=gap_zip, gap_product=gap_product, **kwargs\n            )\n        else:\n            raise InternalError(\"TestParamBundle.__init__ should not reach here.\")\n\n        type(self).add_gap_kwargs(gap_kwargs_dict, self.final_params)\n\n    @staticmethod\n    def parse_param_iter(*args: Iterable[Any], **kwargs: Any) -&gt; List[TestParam]:\n        \"\"\"Parse the param_iter args to param sequence.\"\"\"\n        if kwargs:\n            raise ValueError(\n                \"gap_param_iter=True ignores non-gap kwargs. \"\n                \"Please use `param()` directive to assist specifying kwargs.\"\n            )\n\n        if len(args) != 1:\n            raise ValueError(\"gap_param_iter=True only accepts 1 iterable argument.\")\n\n        arg_iter = args[0]\n\n        return list(\n            arg if isinstance(arg, TestParam) else param(*arg) for arg in arg_iter\n        )\n\n    @staticmethod\n    def parse_params(*args: Iterable[Any], **kwargs: Any) -&gt; List[TestParam]:\n        \"\"\"Parse the parameters for param sequence.\"\"\"\n        if kwargs:\n            raise ValueError(\n                \"gap_params=True ignores non-gap kwargs. \"\n                \"Please use `param()` directive to assist specifying kwargs.\"\n            )\n\n        return list(arg if isinstance(arg, TestParam) else param(*arg) for arg in args)\n\n    @staticmethod\n    def parse_singular_params(*args: Iterable[Any], **kwargs: Any) -&gt; List[TestParam]:\n        \"\"\"Parse the parameters for param sequence.\"\"\"\n        if kwargs:\n            raise ValueError(\n                \"gap_singular_params=True ignores non-gap kwargs. \"\n                \"Please use `param()` directive to assist specifying kwargs.\"\n            )\n\n        return list(arg if isinstance(arg, TestParam) else param(arg) for arg in args)\n\n    @staticmethod\n    def parse_singular_param_iter(\n        *args: Iterable[Any], **kwargs: Any\n    ) -&gt; List[TestParam]:\n        \"\"\"Parse the singular_param_iter args to param sequence.\"\"\"\n        if kwargs:\n            raise ValueError(\n                \"gap_singular_param_iter=True ignores non-gap kwargs. \"\n                \"Please use `param()` directive to assist specifying kwargs.\"\n            )\n\n        if len(args) != 1:\n            raise ValueError(\n                \"gap_singular_param_iter=True only accepts 1 iterable argument.\"\n            )\n\n        arg_iter = args[0]\n\n        return list(\n            arg if isinstance(arg, TestParam) else param(arg) for arg in arg_iter\n        )\n\n    @staticmethod\n    def parse_zip_or_product(\n        *args: Iterable[Any],\n        gap_product: bool = False,\n        gap_zip: bool = False,\n        **kwargs: Any,\n    ) -&gt; List[TestParam]:\n        \"\"\"Parse parameters for zip or product.\n\n        :deprecated: Use params, param_iter, singular_params, singular_param_iter instead.\n        \"\"\"\n        if not gap_zip ^ gap_product:\n            raise ValueError(\"exactly one of gap_zip or gap_product must be True\")\n        combinator = product if gap_product else zip\n\n        # ok so if the combinator is product\n        # we are taking the cartesian product for all args and kwargs\n        # and if the combinator is zip,\n        # we are zipping all the args and kwargs, if there are any\n        combined_args = list(combinator(*args))\n        combined_kwargs = list(combinator(*kwargs.values()))\n\n        # ======= validation checks =======\n        if combinator is zip:\n            # create empty args for zip if there are no args\n            if combined_args and combined_kwargs:\n                if len(combined_args) != len(combined_kwargs):\n                    raise ValueError(\n                        'length of \"args\" and \"kwargs\" must match in zip mode'\n                    )\n            elif combined_args:\n                combined_kwargs = [()] * len(combined_args)\n            elif combined_kwargs:\n                combined_args = [()] * len(combined_kwargs)\n\n        all_args_and_kwargs = list(combinator(combined_args, combined_kwargs))\n\n        # ======= zipping all the args together =======\n        return list(\n            param(*curr_args, **dict(zip(kwargs.keys(), curr_kwargs)))\n            for (curr_args, curr_kwargs) in all_args_and_kwargs\n        )\n\n    @staticmethod\n    def add_gap_kwargs(\n        gap_kwargs: Dict[str, Any], final_params: List[TestParam]\n    ) -&gt; None:\n        \"\"\"Add gap_kwargs to the finalized parameters.\"\"\"\n        # process gap input type\n        for gap_kwarg_key, gap_kwarg_value in gap_kwargs.items():\n            if isinstance(gap_kwarg_value, Iterable) and not isinstance(\n                gap_kwarg_value, str\n            ):\n                gap_kwargs[gap_kwarg_key] = list(gap_kwarg_value)\n            else:\n                gap_kwargs[gap_kwarg_key] = [gap_kwarg_value] * len(final_params)\n\n        # validate gap input type\n        if not all(\n            len(gap_kwarg_value) == len(final_params)\n            for gap_kwarg_value in gap_kwargs.values()\n        ):\n            # the length of the kwargs should be equal to the number of test cases\n            # i.e. the length of the combined args\n            raise ValueError(\n                f\"all gap_ keyword args must have the same length as the test cases, \"\n                f\"which is {len(final_params)}\"\n            )\n\n        # the gap kwargs list we want\n        gap_kwargs_list: List[Dict[str, Any]] = [\n            dict(zip(gap_kwargs.keys(), gap_kwarg_value))\n            for gap_kwarg_value in zip(*gap_kwargs.values())\n        ]\n\n        if not gap_kwargs_list:\n            # generate default gap kwargs dict if there are no gap kwargs\n            gap_kwargs_list = [{} for _ in final_params]\n\n        for final_param, kwargs in zip(final_params, gap_kwargs_list):\n            final_param.update_gap_kwargs(**kwargs)\n\n    def __call__(\n        self, prob: Problem[ProbInputType, ProbOutputType]\n    ) -&gt; Problem[ProbInputType, ProbOutputType]:\n        \"\"\"Generate the test cases as a decorator.\"\"\"\n        for final_param in self.final_params:\n            prob = final_param.register_test_param(prob)\n\n        return prob\n</code></pre>"},{"location":"API/test_cases/#gapper.core.test_parameter.TestParamBundle.__call__","title":"__call__","text":"<pre><code>__call__(prob: Problem[ProbInputType, ProbOutputType]) -&gt; Problem[ProbInputType, ProbOutputType]\n</code></pre> <p>Generate the test cases as a decorator.</p> Source code in <code>src/gapper/core/test_parameter.py</code> <pre><code>def __call__(\n    self, prob: Problem[ProbInputType, ProbOutputType]\n) -&gt; Problem[ProbInputType, ProbOutputType]:\n    \"\"\"Generate the test cases as a decorator.\"\"\"\n    for final_param in self.final_params:\n        prob = final_param.register_test_param(prob)\n\n    return prob\n</code></pre>"},{"location":"API/test_cases/#gapper.core.test_parameter.TestParamBundle.__init__","title":"__init__","text":"<pre><code>__init__(*args: Iterable[Any] | Any, gap_product: bool = False, gap_zip: bool = False, gap_params: bool = False, gap_param_iter: bool = False, gap_singular_params: bool = False, gap_singular_param_iter: bool = False, **kwargs: Any) -&gt; None\n</code></pre> <p>Initialize the test parameter bundle (test_cases).</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Iterable[Any] | Any</code> <p>The arguments for the test parameter bundle.</p> <code>()</code> <code>gap_product</code> <code>bool</code> <p>Whether to take the cartesian product of the arguments. .. deprecated:: Use params, param_iter, singular_params, singular_param_iter instead.</p> <code>False</code> <code>gap_zip</code> <code>bool</code> <p>Whether to zip the arguments. .. deprecated:: Use params, param_iter, singular_params, singular_param_iter instead.</p> <code>False</code> <code>gap_params</code> <code>bool</code> <p>Whether to parse the arguments as parameters.</p> <code>False</code> <code>gap_param_iter</code> <code>bool</code> <p>Whether to parse the argument as parameter iterators.</p> <code>False</code> <code>gap_singular_params</code> <code>bool</code> <p>Whether to parse the arguments as singular parameters.</p> <code>False</code> <code>gap_singular_param_iter</code> <code>bool</code> <p>Whether to parse the arguments as singular parameter iterators.</p> <code>False</code> <code>kwargs</code> <code>Any</code> <p>The keyword arguments for the test parameter bundle. .. seealso:: :class:<code>gapper.core.test_parameter.TestParam</code> .. seealso:: :class:<code>gapper.core.test_parameter.ParamExtractor</code></p> <code>{}</code> Source code in <code>src/gapper/core/test_parameter.py</code> <pre><code>def __init__(\n    self,\n    *args: Iterable[Any] | Any,\n    gap_product: bool = False,\n    gap_zip: bool = False,\n    gap_params: bool = False,\n    gap_param_iter: bool = False,\n    gap_singular_params: bool = False,\n    gap_singular_param_iter: bool = False,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Initialize the test parameter bundle (test_cases).\n\n    :param args: The arguments for the test parameter bundle.\n    :param gap_product: Whether to take the cartesian product of the arguments.\n        .. deprecated::\n            Use params, param_iter, singular_params, singular_param_iter instead.\n    :param gap_zip: Whether to zip the arguments.\n        .. deprecated::\n            Use params, param_iter, singular_params, singular_param_iter instead.\n    :param gap_params: Whether to parse the arguments as parameters.\n    :param gap_param_iter: Whether to parse the argument as parameter iterators.\n    :param gap_singular_params: Whether to parse the arguments as singular parameters.\n    :param gap_singular_param_iter: Whether to parse the arguments as singular parameter iterators.\n    :param kwargs: The keyword arguments for the test parameter bundle.\n        .. seealso::\n            :class:`gapper.core.test_parameter.TestParam`\n        .. seealso::\n            :class:`gapper.core.test_parameter.ParamExtractor`\n    \"\"\"\n    if (\n        gap_params\n        + gap_param_iter\n        + gap_zip\n        + gap_product\n        + gap_singular_params\n        + gap_singular_param_iter\n    ) != 1:\n        raise ValueError(\n            \"Exactly many of gap_product, gap_zip, or gap_params are True. \"\n            \"Only 1 of the flags is allowed. \\n\"\n            f\"You got: \"\n            f\"gap_product={gap_product}, gap_zip={gap_zip}, \"\n            f\"gap_params={gap_params}, gap_singular_params={gap_singular_params}\"\n        )\n\n    if gap_product:\n        raise warnings.warn(\"gap_product is deprecated.\")\n    if gap_zip:\n        raise warnings.warn(\"gap_zip is deprecated.\")\n\n    # pop gap keywords out\n    gap_kwargs_dict = ParamExtractor.extra_gap_info(kwargs)\n\n    if gap_params:\n        self.final_params: List[TestParam] = type(self).parse_params(\n            *args, **kwargs\n        )\n    elif gap_param_iter:\n        self.final_params = type(self).parse_param_iter(*args, **kwargs)\n    elif gap_singular_params:\n        self.final_params = type(self).parse_singular_params(*args, **kwargs)\n    elif gap_singular_param_iter:\n        self.final_params = type(self).parse_singular_param_iter(*args, **kwargs)\n    elif gap_zip or gap_product:\n        self.final_params = type(self).parse_zip_or_product(\n            *args, gap_zip=gap_zip, gap_product=gap_product, **kwargs\n        )\n    else:\n        raise InternalError(\"TestParamBundle.__init__ should not reach here.\")\n\n    type(self).add_gap_kwargs(gap_kwargs_dict, self.final_params)\n</code></pre>"},{"location":"API/test_cases/#gapper.core.test_parameter.TestParamBundle.add_gap_kwargs","title":"add_gap_kwargs  <code>staticmethod</code>","text":"<pre><code>add_gap_kwargs(gap_kwargs: Dict[str, Any], final_params: List[TestParam]) -&gt; None\n</code></pre> <p>Add gap_kwargs to the finalized parameters.</p> Source code in <code>src/gapper/core/test_parameter.py</code> <pre><code>@staticmethod\ndef add_gap_kwargs(\n    gap_kwargs: Dict[str, Any], final_params: List[TestParam]\n) -&gt; None:\n    \"\"\"Add gap_kwargs to the finalized parameters.\"\"\"\n    # process gap input type\n    for gap_kwarg_key, gap_kwarg_value in gap_kwargs.items():\n        if isinstance(gap_kwarg_value, Iterable) and not isinstance(\n            gap_kwarg_value, str\n        ):\n            gap_kwargs[gap_kwarg_key] = list(gap_kwarg_value)\n        else:\n            gap_kwargs[gap_kwarg_key] = [gap_kwarg_value] * len(final_params)\n\n    # validate gap input type\n    if not all(\n        len(gap_kwarg_value) == len(final_params)\n        for gap_kwarg_value in gap_kwargs.values()\n    ):\n        # the length of the kwargs should be equal to the number of test cases\n        # i.e. the length of the combined args\n        raise ValueError(\n            f\"all gap_ keyword args must have the same length as the test cases, \"\n            f\"which is {len(final_params)}\"\n        )\n\n    # the gap kwargs list we want\n    gap_kwargs_list: List[Dict[str, Any]] = [\n        dict(zip(gap_kwargs.keys(), gap_kwarg_value))\n        for gap_kwarg_value in zip(*gap_kwargs.values())\n    ]\n\n    if not gap_kwargs_list:\n        # generate default gap kwargs dict if there are no gap kwargs\n        gap_kwargs_list = [{} for _ in final_params]\n\n    for final_param, kwargs in zip(final_params, gap_kwargs_list):\n        final_param.update_gap_kwargs(**kwargs)\n</code></pre>"},{"location":"API/test_cases/#gapper.core.test_parameter.TestParamBundle.parse_param_iter","title":"parse_param_iter  <code>staticmethod</code>","text":"<pre><code>parse_param_iter(*args: Iterable[Any], **kwargs: Any) -&gt; List[TestParam]\n</code></pre> <p>Parse the param_iter args to param sequence.</p> Source code in <code>src/gapper/core/test_parameter.py</code> <pre><code>@staticmethod\ndef parse_param_iter(*args: Iterable[Any], **kwargs: Any) -&gt; List[TestParam]:\n    \"\"\"Parse the param_iter args to param sequence.\"\"\"\n    if kwargs:\n        raise ValueError(\n            \"gap_param_iter=True ignores non-gap kwargs. \"\n            \"Please use `param()` directive to assist specifying kwargs.\"\n        )\n\n    if len(args) != 1:\n        raise ValueError(\"gap_param_iter=True only accepts 1 iterable argument.\")\n\n    arg_iter = args[0]\n\n    return list(\n        arg if isinstance(arg, TestParam) else param(*arg) for arg in arg_iter\n    )\n</code></pre>"},{"location":"API/test_cases/#gapper.core.test_parameter.TestParamBundle.parse_params","title":"parse_params  <code>staticmethod</code>","text":"<pre><code>parse_params(*args: Iterable[Any], **kwargs: Any) -&gt; List[TestParam]\n</code></pre> <p>Parse the parameters for param sequence.</p> Source code in <code>src/gapper/core/test_parameter.py</code> <pre><code>@staticmethod\ndef parse_params(*args: Iterable[Any], **kwargs: Any) -&gt; List[TestParam]:\n    \"\"\"Parse the parameters for param sequence.\"\"\"\n    if kwargs:\n        raise ValueError(\n            \"gap_params=True ignores non-gap kwargs. \"\n            \"Please use `param()` directive to assist specifying kwargs.\"\n        )\n\n    return list(arg if isinstance(arg, TestParam) else param(*arg) for arg in args)\n</code></pre>"},{"location":"API/test_cases/#gapper.core.test_parameter.TestParamBundle.parse_singular_param_iter","title":"parse_singular_param_iter  <code>staticmethod</code>","text":"<pre><code>parse_singular_param_iter(*args: Iterable[Any], **kwargs: Any) -&gt; List[TestParam]\n</code></pre> <p>Parse the singular_param_iter args to param sequence.</p> Source code in <code>src/gapper/core/test_parameter.py</code> <pre><code>@staticmethod\ndef parse_singular_param_iter(\n    *args: Iterable[Any], **kwargs: Any\n) -&gt; List[TestParam]:\n    \"\"\"Parse the singular_param_iter args to param sequence.\"\"\"\n    if kwargs:\n        raise ValueError(\n            \"gap_singular_param_iter=True ignores non-gap kwargs. \"\n            \"Please use `param()` directive to assist specifying kwargs.\"\n        )\n\n    if len(args) != 1:\n        raise ValueError(\n            \"gap_singular_param_iter=True only accepts 1 iterable argument.\"\n        )\n\n    arg_iter = args[0]\n\n    return list(\n        arg if isinstance(arg, TestParam) else param(arg) for arg in arg_iter\n    )\n</code></pre>"},{"location":"API/test_cases/#gapper.core.test_parameter.TestParamBundle.parse_singular_params","title":"parse_singular_params  <code>staticmethod</code>","text":"<pre><code>parse_singular_params(*args: Iterable[Any], **kwargs: Any) -&gt; List[TestParam]\n</code></pre> <p>Parse the parameters for param sequence.</p> Source code in <code>src/gapper/core/test_parameter.py</code> <pre><code>@staticmethod\ndef parse_singular_params(*args: Iterable[Any], **kwargs: Any) -&gt; List[TestParam]:\n    \"\"\"Parse the parameters for param sequence.\"\"\"\n    if kwargs:\n        raise ValueError(\n            \"gap_singular_params=True ignores non-gap kwargs. \"\n            \"Please use `param()` directive to assist specifying kwargs.\"\n        )\n\n    return list(arg if isinstance(arg, TestParam) else param(arg) for arg in args)\n</code></pre>"},{"location":"API/test_cases/#gapper.core.test_parameter.TestParamBundle.parse_zip_or_product","title":"parse_zip_or_product  <code>staticmethod</code>","text":"<pre><code>parse_zip_or_product(*args: Iterable[Any], gap_product: bool = False, gap_zip: bool = False, **kwargs: Any) -&gt; List[TestParam]\n</code></pre> <p>Parse parameters for zip or product.</p> <p>:deprecated: Use params, param_iter, singular_params, singular_param_iter instead.</p> Source code in <code>src/gapper/core/test_parameter.py</code> <pre><code>@staticmethod\ndef parse_zip_or_product(\n    *args: Iterable[Any],\n    gap_product: bool = False,\n    gap_zip: bool = False,\n    **kwargs: Any,\n) -&gt; List[TestParam]:\n    \"\"\"Parse parameters for zip or product.\n\n    :deprecated: Use params, param_iter, singular_params, singular_param_iter instead.\n    \"\"\"\n    if not gap_zip ^ gap_product:\n        raise ValueError(\"exactly one of gap_zip or gap_product must be True\")\n    combinator = product if gap_product else zip\n\n    # ok so if the combinator is product\n    # we are taking the cartesian product for all args and kwargs\n    # and if the combinator is zip,\n    # we are zipping all the args and kwargs, if there are any\n    combined_args = list(combinator(*args))\n    combined_kwargs = list(combinator(*kwargs.values()))\n\n    # ======= validation checks =======\n    if combinator is zip:\n        # create empty args for zip if there are no args\n        if combined_args and combined_kwargs:\n            if len(combined_args) != len(combined_kwargs):\n                raise ValueError(\n                    'length of \"args\" and \"kwargs\" must match in zip mode'\n                )\n        elif combined_args:\n            combined_kwargs = [()] * len(combined_args)\n        elif combined_kwargs:\n            combined_args = [()] * len(combined_kwargs)\n\n    all_args_and_kwargs = list(combinator(combined_args, combined_kwargs))\n\n    # ======= zipping all the args together =======\n    return list(\n        param(*curr_args, **dict(zip(kwargs.keys(), curr_kwargs)))\n        for (curr_args, curr_kwargs) in all_args_and_kwargs\n    )\n</code></pre>"},{"location":"API/test_cases/#gap__hooks-api","title":"<code>gap_*_hooks</code> API","text":""},{"location":"API/test_cases/#gapper.core.unittest_wrapper.wrapper_hooks.pre_hook","title":"pre_hook  <code>module-attribute</code>","text":"<pre><code>pre_hook = PreHook\n</code></pre>"},{"location":"API/test_cases/#gapper.core.unittest_wrapper.wrapper_hooks.post_hook","title":"post_hook  <code>module-attribute</code>","text":"<pre><code>post_hook = PostHook\n</code></pre>"},{"location":"API/test_cases/#gapper.core.unittest_wrapper.wrapper_hooks.PreHook","title":"PreHook","text":"<p>             Bases: <code>HookBase</code></p> Source code in <code>src/gapper/core/unittest_wrapper/wrapper_hooks.py</code> <pre><code>class PreHook(HookBase):\n    _hook_type = HookTypes.PRE_HOOK\n\n    def __init__(self, hook_fn: PreHookFn, **kwargs) -&gt; None:\n        super().__init__(hook_fn, as_test_case=False, **kwargs)\n</code></pre>"},{"location":"API/test_cases/#gapper.core.unittest_wrapper.wrapper_hooks.PostHook","title":"PostHook","text":"<p>             Bases: <code>HookBase</code></p> Source code in <code>src/gapper/core/unittest_wrapper/wrapper_hooks.py</code> <pre><code>class PostHook(HookBase):\n    _hook_type = HookTypes.POST_HOOK\n\n    def __init__(self, hook_fn: PostHookFn, **kwargs) -&gt; None:\n        super().__init__(hook_fn, as_test_case=False, **kwargs)\n</code></pre>"},{"location":"API/test_result/","title":"<code>TestResult</code> -- Test Result Proxy","text":""},{"location":"API/test_result/#api","title":"API","text":"<p>The module for the test result.</p>"},{"location":"API/test_result/#gapper.core.test_result.TestResult","title":"TestResult  <code>dataclass</code>","text":"<p>Test result for a single test case.</p> <p>Parameters:</p> Name Type Description Default <code>default_name</code> <code>str</code> <p>The default name of the test.</p> required <code>name</code> <code>str | None</code> <p>The name of the test.</p> <code>None</code> <code>score</code> <code>float | None</code> <p>The score obtained by the test.</p> <code>None</code> <code>max_score</code> <code>float | None</code> <p>The max score can obtained for the test.</p> <code>None</code> <code>weight</code> <code>int | None</code> <p>The weight of the test.</p> <code>None</code> <code>extra_points</code> <code>float | None</code> <p>The extra points of the test, applied when the test is passed.</p> <code>None</code> <code>errors</code> <code>List[ErrorFormatter]</code> <p>The errors of the test.</p> <code>list()</code> <code>pass_status</code> <code>PassStateType | None</code> <p>The pass status of the test.</p> <code>None</code> <code>hidden</code> <code>bool</code> <p>Whether the test is hidden.</p> <code>False</code> <code>descriptions</code> <code>List[str]</code> <p>The descriptions of the test.</p> <code>list()</code> Source code in <code>src/gapper/core/test_result.py</code> <pre><code>@dataclass\nclass TestResult:\n    \"\"\"Test result for a single test case.\n\n    :param default_name: The default name of the test.\n    :param name: The name of the test.\n    :param score: The score obtained by the test.\n    :param max_score: The max score can obtained for the test.\n    :param weight: The weight of the test.\n    :param extra_points: The extra points of the test, applied when the test is passed.\n    :param errors: The errors of the test.\n    :param pass_status: The pass status of the test.\n    :param hidden: Whether the test is hidden.\n    :param descriptions: The descriptions of the test.\n    \"\"\"\n\n    default_name: str\n    name: str | None = None\n    score: float | None = field(default=None)\n    max_score: float | None = field(default=None)\n    weight: int | None = field(default=None)\n    extra_points: float | None = field(default=None)\n    errors: List[ErrorFormatter] = field(default_factory=list)\n    pass_status: PassStateType | None = field(default=None)\n    hidden: bool = False\n    descriptions: List[str] = field(default_factory=list)\n\n    @property\n    def rich_test_name(self) -&gt; str:\n        \"\"\"The name of the test, with the default name prepended if the name is unset.\"\"\"\n        name = f\"{self.name} \" if self.name else \"\"\n        default_name = self.default_name\n        return \"{}{}\".format(name, default_name)\n\n    @property\n    def rich_test_output(self) -&gt; str:\n        \"\"\"The description output of the test, with the score and max score appended if set.\"\"\"\n        pass_status_msg = self.pass_status.capitalize() if self.pass_status else \"\"\n\n        description_info = indent(\"\\n\".join(self.descriptions), \" \" * 2)\n        description_msg = (\n            \"Description(s): \\n\" + description_info if self.descriptions else \"\"\n        )\n\n        error_info = indent(\n            \"\\n\".join(err.format() for err in self.errors),\n            \" \" * 2,\n        )\n        error_msg = \"Error(s): \\n\" + error_info if self.errors else \"\"\n\n        messages = list(filter(bool, [pass_status_msg, description_msg, error_msg]))\n        if len(messages) == 0:\n            return \"&lt;No Description&gt;\"\n        else:\n            return \"\\n\".join(messages)\n\n    def set_name(self, name: str) -&gt; None:\n        \"\"\"Set the name of the test.\n\n        This does not modify the default name.\n        \"\"\"\n        self.name = name\n\n    def add_description(self, *detail: str) -&gt; None:\n        \"\"\"Add a description to the test.\n\n        New descriptions are added as newlines to the end of the existing descriptions.\n\n        :param detail: The description to add.\n        \"\"\"\n        self.descriptions.extend(detail)\n\n    def set_descriptions(self, detail: Iterable[str]) -&gt; None:\n        \"\"\"Set the description of the test.\n\n        This overrides all the existing descriptions.\n\n        :param detail: The description to set.\n        \"\"\"\n        self.descriptions = list(detail)\n\n    def set_hidden(self, hidden: bool) -&gt; None:\n        \"\"\"Set the hidden status of the test.\n\n        :param hidden: Whether the test is hidden.\n        \"\"\"\n        self.hidden = hidden\n\n    def set_score(self, score: float) -&gt; None:\n        \"\"\"Set the score of the test.\n\n        :param score: The score to set.\n        \"\"\"\n        self.score = score\n\n    def set_max_score(self, max_score: float | None) -&gt; None:\n        \"\"\"Set the max score of the test.\n\n        :param max_score: The max score of this test case to set.\n        \"\"\"\n        self.max_score = max_score\n\n    def set_weight(self, weight: int | None) -&gt; None:\n        \"\"\"Set the weight of the test.\n\n        :param weight: The weight of this test case to set.\n        \"\"\"\n        self.weight = weight\n\n    def set_extra_points(self, score: float | None) -&gt; None:\n        \"\"\"Set the extra points of the test.\n\n        :param score: The extra points of this test case to set.\n        \"\"\"\n        self.extra_points = score\n\n    def add_error(self, error: ErrorFormatter, set_failed: bool = True) -&gt; None:\n        \"\"\"Add an error to the test.\n\n        :param error: The error to add.\n        :param set_failed: Whether to set the pass status to failed.\n        \"\"\"\n        self.errors.append(error)\n        if set_failed:\n            self.set_pass_status(\"failed\")\n\n    @property\n    def is_passed(self) -&gt; bool:\n        \"\"\"Whether the test passed.\"\"\"\n        return self.pass_status == \"passed\"\n\n    @property\n    def is_pass_status_unset(self) -&gt; bool:\n        \"\"\"Whether the pass status is unset.\"\"\"\n        return self.pass_status is None\n\n    def set_pass_status(self, status: PassStateType) -&gt; None:\n        \"\"\"Set the pass status of the test.\n\n        :param status: The pass status to set.\n        \"\"\"\n        self.pass_status = status\n\n    def set_default_weight(self) -&gt; None:\n        \"\"\"Set the weight of the test to 1.\"\"\"\n        self.weight = 1\n</code></pre>"},{"location":"API/test_result/#gapper.core.test_result.TestResult.is_pass_status_unset","title":"is_pass_status_unset  <code>property</code>","text":"<pre><code>is_pass_status_unset: bool\n</code></pre> <p>Whether the pass status is unset.</p>"},{"location":"API/test_result/#gapper.core.test_result.TestResult.is_passed","title":"is_passed  <code>property</code>","text":"<pre><code>is_passed: bool\n</code></pre> <p>Whether the test passed.</p>"},{"location":"API/test_result/#gapper.core.test_result.TestResult.rich_test_name","title":"rich_test_name  <code>property</code>","text":"<pre><code>rich_test_name: str\n</code></pre> <p>The name of the test, with the default name prepended if the name is unset.</p>"},{"location":"API/test_result/#gapper.core.test_result.TestResult.rich_test_output","title":"rich_test_output  <code>property</code>","text":"<pre><code>rich_test_output: str\n</code></pre> <p>The description output of the test, with the score and max score appended if set.</p>"},{"location":"API/test_result/#gapper.core.test_result.TestResult.add_description","title":"add_description","text":"<pre><code>add_description(*detail: str) -&gt; None\n</code></pre> <p>Add a description to the test.</p> <p>New descriptions are added as newlines to the end of the existing descriptions.</p> <p>Parameters:</p> Name Type Description Default <code>detail</code> <code>str</code> <p>The description to add.</p> <code>()</code> Source code in <code>src/gapper/core/test_result.py</code> <pre><code>def add_description(self, *detail: str) -&gt; None:\n    \"\"\"Add a description to the test.\n\n    New descriptions are added as newlines to the end of the existing descriptions.\n\n    :param detail: The description to add.\n    \"\"\"\n    self.descriptions.extend(detail)\n</code></pre>"},{"location":"API/test_result/#gapper.core.test_result.TestResult.add_error","title":"add_error","text":"<pre><code>add_error(error: ErrorFormatter, set_failed: bool = True) -&gt; None\n</code></pre> <p>Add an error to the test.</p> <p>Parameters:</p> Name Type Description Default <code>error</code> <code>ErrorFormatter</code> <p>The error to add.</p> required <code>set_failed</code> <code>bool</code> <p>Whether to set the pass status to failed.</p> <code>True</code> Source code in <code>src/gapper/core/test_result.py</code> <pre><code>def add_error(self, error: ErrorFormatter, set_failed: bool = True) -&gt; None:\n    \"\"\"Add an error to the test.\n\n    :param error: The error to add.\n    :param set_failed: Whether to set the pass status to failed.\n    \"\"\"\n    self.errors.append(error)\n    if set_failed:\n        self.set_pass_status(\"failed\")\n</code></pre>"},{"location":"API/test_result/#gapper.core.test_result.TestResult.set_default_weight","title":"set_default_weight","text":"<pre><code>set_default_weight() -&gt; None\n</code></pre> <p>Set the weight of the test to 1.</p> Source code in <code>src/gapper/core/test_result.py</code> <pre><code>def set_default_weight(self) -&gt; None:\n    \"\"\"Set the weight of the test to 1.\"\"\"\n    self.weight = 1\n</code></pre>"},{"location":"API/test_result/#gapper.core.test_result.TestResult.set_descriptions","title":"set_descriptions","text":"<pre><code>set_descriptions(detail: Iterable[str]) -&gt; None\n</code></pre> <p>Set the description of the test.</p> <p>This overrides all the existing descriptions.</p> <p>Parameters:</p> Name Type Description Default <code>detail</code> <code>Iterable[str]</code> <p>The description to set.</p> required Source code in <code>src/gapper/core/test_result.py</code> <pre><code>def set_descriptions(self, detail: Iterable[str]) -&gt; None:\n    \"\"\"Set the description of the test.\n\n    This overrides all the existing descriptions.\n\n    :param detail: The description to set.\n    \"\"\"\n    self.descriptions = list(detail)\n</code></pre>"},{"location":"API/test_result/#gapper.core.test_result.TestResult.set_extra_points","title":"set_extra_points","text":"<pre><code>set_extra_points(score: float | None) -&gt; None\n</code></pre> <p>Set the extra points of the test.</p> <p>Parameters:</p> Name Type Description Default <code>score</code> <code>float | None</code> <p>The extra points of this test case to set.</p> required Source code in <code>src/gapper/core/test_result.py</code> <pre><code>def set_extra_points(self, score: float | None) -&gt; None:\n    \"\"\"Set the extra points of the test.\n\n    :param score: The extra points of this test case to set.\n    \"\"\"\n    self.extra_points = score\n</code></pre>"},{"location":"API/test_result/#gapper.core.test_result.TestResult.set_hidden","title":"set_hidden","text":"<pre><code>set_hidden(hidden: bool) -&gt; None\n</code></pre> <p>Set the hidden status of the test.</p> <p>Parameters:</p> Name Type Description Default <code>hidden</code> <code>bool</code> <p>Whether the test is hidden.</p> required Source code in <code>src/gapper/core/test_result.py</code> <pre><code>def set_hidden(self, hidden: bool) -&gt; None:\n    \"\"\"Set the hidden status of the test.\n\n    :param hidden: Whether the test is hidden.\n    \"\"\"\n    self.hidden = hidden\n</code></pre>"},{"location":"API/test_result/#gapper.core.test_result.TestResult.set_max_score","title":"set_max_score","text":"<pre><code>set_max_score(max_score: float | None) -&gt; None\n</code></pre> <p>Set the max score of the test.</p> <p>Parameters:</p> Name Type Description Default <code>max_score</code> <code>float | None</code> <p>The max score of this test case to set.</p> required Source code in <code>src/gapper/core/test_result.py</code> <pre><code>def set_max_score(self, max_score: float | None) -&gt; None:\n    \"\"\"Set the max score of the test.\n\n    :param max_score: The max score of this test case to set.\n    \"\"\"\n    self.max_score = max_score\n</code></pre>"},{"location":"API/test_result/#gapper.core.test_result.TestResult.set_name","title":"set_name","text":"<pre><code>set_name(name: str) -&gt; None\n</code></pre> <p>Set the name of the test.</p> <p>This does not modify the default name.</p> Source code in <code>src/gapper/core/test_result.py</code> <pre><code>def set_name(self, name: str) -&gt; None:\n    \"\"\"Set the name of the test.\n\n    This does not modify the default name.\n    \"\"\"\n    self.name = name\n</code></pre>"},{"location":"API/test_result/#gapper.core.test_result.TestResult.set_pass_status","title":"set_pass_status","text":"<pre><code>set_pass_status(status: PassStateType) -&gt; None\n</code></pre> <p>Set the pass status of the test.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>PassStateType</code> <p>The pass status to set.</p> required Source code in <code>src/gapper/core/test_result.py</code> <pre><code>def set_pass_status(self, status: PassStateType) -&gt; None:\n    \"\"\"Set the pass status of the test.\n\n    :param status: The pass status to set.\n    \"\"\"\n    self.pass_status = status\n</code></pre>"},{"location":"API/test_result/#gapper.core.test_result.TestResult.set_score","title":"set_score","text":"<pre><code>set_score(score: float) -&gt; None\n</code></pre> <p>Set the score of the test.</p> <p>Parameters:</p> Name Type Description Default <code>score</code> <code>float</code> <p>The score to set.</p> required Source code in <code>src/gapper/core/test_result.py</code> <pre><code>def set_score(self, score: float) -&gt; None:\n    \"\"\"Set the score of the test.\n\n    :param score: The score to set.\n    \"\"\"\n    self.score = score\n</code></pre>"},{"location":"API/test_result/#gapper.core.test_result.TestResult.set_weight","title":"set_weight","text":"<pre><code>set_weight(weight: int | None) -&gt; None\n</code></pre> <p>Set the weight of the test.</p> <p>Parameters:</p> Name Type Description Default <code>weight</code> <code>int | None</code> <p>The weight of this test case to set.</p> required Source code in <code>src/gapper/core/test_result.py</code> <pre><code>def set_weight(self, weight: int | None) -&gt; None:\n    \"\"\"Set the weight of the test.\n\n    :param weight: The weight of this test case to set.\n    \"\"\"\n    self.weight = weight\n</code></pre>"},{"location":"API/tester/","title":"<code>Tester</code>, <code>pre_tests</code> and <code>post_tests</code>","text":""},{"location":"API/tester/#note","title":"Note","text":"<p><code>post_tests</code> is an alias of <code>PostTest</code> and <code>pre_tests</code> is an alias of <code>PreTest</code>. That is</p> <pre><code>from gapper import post_tests, pre_tests\nfrom gapper.core.tester import PostTests, PreTests\n\nassert post_tests is PostTests\nassert pre_tests is PreTests\n</code></pre>"},{"location":"API/tester/#tester-api","title":"Tester API","text":"<p>Tester class and helper definitions.</p>"},{"location":"API/tester/#gapper.core.tester.tester_def.ProblemUnpickler","title":"ProblemUnpickler","text":"<p>             Bases: <code>Unpickler</code></p> <p>The unpickler for the problem class.</p> Source code in <code>src/gapper/core/tester/tester_def.py</code> <pre><code>class ProblemUnpickler(Unpickler):\n    \"\"\"The unpickler for the problem class.\"\"\"\n\n    def find_class(self, module: str, name: str) -&gt; Any:\n        \"\"\"Find the class from the module and name.\"\"\"\n        match name:\n            case \"Problem\":\n                from gapper.core.problem import Problem\n\n                return Problem\n            case \"Tester\":\n                return Tester\n\n        return super().find_class(module, name)\n</code></pre>"},{"location":"API/tester/#gapper.core.tester.tester_def.ProblemUnpickler.find_class","title":"find_class","text":"<pre><code>find_class(module: str, name: str) -&gt; Any\n</code></pre> <p>Find the class from the module and name.</p> Source code in <code>src/gapper/core/tester/tester_def.py</code> <pre><code>def find_class(self, module: str, name: str) -&gt; Any:\n    \"\"\"Find the class from the module and name.\"\"\"\n    match name:\n        case \"Problem\":\n            from gapper.core.problem import Problem\n\n            return Problem\n        case \"Tester\":\n            return Tester\n\n    return super().find_class(module, name)\n</code></pre>"},{"location":"API/tester/#gapper.core.tester.tester_def.Tester","title":"Tester","text":"<p>             Bases: <code>HookHolder</code>, <code>ModuleLoader</code></p> <p>The tester class, handling test cases' testing.</p> Source code in <code>src/gapper/core/tester/tester_def.py</code> <pre><code>class Tester[ProbInputType, ProbOutputType](HookHolder, ModuleLoader):\n    \"\"\"The tester class, handling test cases' testing.\"\"\"\n\n    def __init__(\n        self,\n        problem: Problem[ProbInputType, ProbOutputType],\n    ) -&gt; None:\n        \"\"\"Create a tester object.\n\n        :param problem: The problem to be tested.\n        \"\"\"\n        super().__init__()\n        self._problem: Problem[ProbInputType, ProbOutputType] = problem\n        self._submission: Any | None = None\n        self._submission_context: ContextManager = ContextManager()\n        self._logger = _tester_logger.getChild(\n            f\"Tester_{problem and problem.expected_submission_name}\"\n        )\n\n    @property\n    def problem(self) -&gt; Problem[ProbInputType, ProbOutputType]:\n        \"\"\"The problem to be tested.\"\"\"\n        return self._problem\n\n    @problem.setter\n    def problem(self, prob: Problem[ProbInputType, ProbOutputType]) -&gt; None:\n        \"\"\"Set the problem to be tested.\"\"\"\n        self._problem = prob\n\n    @property\n    def submission(self) -&gt; Any | None:\n        \"\"\"The submission to be tested against.\"\"\"\n        return self._submission\n\n    @property\n    def submission_context(self) -&gt; ContextManager:\n        \"\"\"The context of captured from the submission.\"\"\"\n        return self._submission_context\n\n    def generate_hooks(self, hook_type: HookTypes) -&gt; None:\n        match hook_type:\n            case HookTypes.PRE_TESTS:\n                self._hooks[hook_type] = self.problem.pre_tests_hooks\n            case HookTypes.POST_TESTS:\n                self._hooks[hook_type] = self.problem.post_tests_hooks\n            case _:\n                raise ValueError(f\"Tester cannot use hook of type {hook_type}\")\n\n    def run_hooks(self, hook_type: HookTypes, data: HookDataBase) -&gt; List[TestResult]:\n        results: List[TestResult] = []\n        hooks = self.get_or_gen_hooks(hook_type)\n        for hook in hooks:\n            result = hook.run(data)\n            if result is not None:\n                results.append(result)\n\n        self._logger.debug(f\"Running hook {hook_type} finished\")\n        return results\n\n    def _load_script_submission_from_path(\n        self, path: Path\n    ) -&gt; Generator[Callable[[], None], None, None]:\n        if path.is_dir():\n            for sub_path in path.iterdir():\n                yield from self._load_script_submission_from_path(sub_path)\n        else:\n            if path.suffix != \".py\":\n                return None\n\n            spec, md = self._load_module_spec_and_module(path)\n\n            def run_script() -&gt; None:\n                assert spec.loader is not None\n                spec.loader.exec_module(md)\n\n            yield run_script\n\n    def _load_object_submission_from_path(self, path: Path) -&gt; Any:\n        if path.is_dir():\n            for sub_path in path.iterdir():\n                yield from self._load_object_submission_from_path(sub_path)\n        else:\n            if path.suffix != \".py\":\n                return None\n\n            spec, md = self._load_module_spec_and_module(path, exec_mod=True)\n\n            self.load_context_from_module(md)\n\n            try:\n                yield self._load_symbol_from_module(\n                    md, self.problem.expected_submission_name\n                )\n            except AttributeError:\n                return None\n\n    def load_submission_from_path(self, path: Path) -&gt; Self:\n        \"\"\"Load the submission from a path.\n\n        :param path: The path to load the submission from. If the path is a directory, it will be searched recursively.\n        :raises NoSubmissionError: If no submission is found.\n        :raises MultipleSubmissionError: If multiple submissions are found.\n        \"\"\"\n        if self.problem.config.is_script:\n            self._logger.debug(\"Loading script submission\")\n            submission_list = list(self._load_script_submission_from_path(path))\n        else:\n            self._logger.debug(\"Loading object submission\")\n            submission_list = list(self._load_object_submission_from_path(path))\n\n        self._logger.debug(\n            f\"Found {len(submission_list)} submissions: {submission_list}\"\n        )\n\n        if len(submission_list) == 0:\n            raise NoSubmissionError(self.problem.expected_submission_name)\n        elif len(submission_list) &gt; 1:\n            raise MultipleSubmissionError(self.problem.expected_submission_name)\n\n        self._submission = submission_list[0]\n        self._logger.debug(\"Submission loaded\")\n\n        return self\n\n    def load_context_from_module(self, md: ModuleType) -&gt; Self:\n        \"\"\"Load the context from a module.\n\n        :param md: The module to load the context from.\n        :raises MultipleContextValueError: If multiple context values are found.\n        \"\"\"\n        for context_value_name in self.problem.config.captured_context:\n            try:\n                context_value = self._load_symbol_from_module(md, context_value_name)\n            except AttributeError:\n                continue\n\n            if context_value_name in self.submission_context:\n                raise MultipleContextValueError(context_value_name)\n\n            self.submission_context[context_value_name] = context_value\n            self._logger.debug(\n                f\"Loaded context value for {context_value_name} from {md}\"\n            )\n\n        return self\n\n    def check_context_completeness(self) -&gt; None:\n        \"\"\"Check if the context is complete against what's required in the problem.\"\"\"\n        for context_value_name in self.problem.config.captured_context:\n            if context_value_name not in self.submission_context:\n                raise MissingContextValueError(context_value_name)\n\n        self._logger.debug(\"Context completeness check passed\")\n\n    def run(\n        self, metadata: GradescopeSubmissionMetadata | None = None\n    ) -&gt; List[TestResult]:\n        \"\"\"Run the tests.\n\n        :param metadata: The metadata of the submission, which could be None.\n        \"\"\"\n        if self.problem is None:\n            raise InternalError(\"No problem loaded.\")\n\n        if self.submission is None:\n            raise InternalError(\"No submission loaded.\")\n\n        self.check_context_completeness()\n\n        pre_results = self.run_hooks(\n            HookTypes.PRE_TESTS, PreTestsData(metadata=metadata)\n        )\n        test_results = self.run_tests(metadata=metadata)\n        post_test_result = self.run_hooks(\n            HookTypes.POST_TESTS,\n            PostTestsData(test_results=test_results, metadata=metadata),\n        )\n        self.tear_down_hooks(HookTypes.PRE_TESTS)\n        self.tear_down_hooks(HookTypes.PRE_TESTS)\n\n        return [*pre_results, *test_results, *post_test_result]\n\n    def run_tests(\n        self, metadata: GradescopeSubmissionMetadata | None\n    ) -&gt; List[TestResult]:\n        test_results: List[TestResult] = []\n\n        for test in self.problem.generate_tests():\n            self._logger.debug(f\"Running test {test.test_param.format()}\")\n\n            test_results.append(\n                test.load_metadata(metadata)\n                .load_context(self.submission_context)\n                .run_test(\n                    deepcopy(self.submission),\n                    TestResult(default_name=test.test_param.format()),\n                )\n            )\n\n        return test_results\n\n    @classmethod\n    def from_file(cls, path: Path) -&gt; Tester:\n        \"\"\"Load a tester from a file.\n\n        :param path: The path to load the tester from.\n        \"\"\"\n        with open(path, \"rb\") as f:\n            tester = ProblemUnpickler(f).load()\n\n        _tester_logger.debug(f\"Tester loaded from path {path.absolute()}\")\n\n        return tester\n\n    def dump_to(self, path: Path | str) -&gt; None:\n        \"\"\"Dump the tester to a file.\n\n        :param path: The path to dump the tester to.\n        \"\"\"\n        with open(path, \"wb\") as f:\n            dump(self, f)\n\n        _tester_logger.debug(f\"Tester dumped to path {path.absolute()}\")\n</code></pre>"},{"location":"API/tester/#gapper.core.tester.tester_def.Tester.problem","title":"problem  <code>property</code> <code>writable</code>","text":"<pre><code>problem: Problem[ProbInputType, ProbOutputType]\n</code></pre> <p>The problem to be tested.</p>"},{"location":"API/tester/#gapper.core.tester.tester_def.Tester.submission","title":"submission  <code>property</code>","text":"<pre><code>submission: Any | None\n</code></pre> <p>The submission to be tested against.</p>"},{"location":"API/tester/#gapper.core.tester.tester_def.Tester.submission_context","title":"submission_context  <code>property</code>","text":"<pre><code>submission_context: ContextManager\n</code></pre> <p>The context of captured from the submission.</p>"},{"location":"API/tester/#gapper.core.tester.tester_def.Tester.__init__","title":"__init__","text":"<pre><code>__init__(problem: Problem[ProbInputType, ProbOutputType]) -&gt; None\n</code></pre> <p>Create a tester object.</p> <p>Parameters:</p> Name Type Description Default <code>problem</code> <code>Problem[ProbInputType, ProbOutputType]</code> <p>The problem to be tested.</p> required Source code in <code>src/gapper/core/tester/tester_def.py</code> <pre><code>def __init__(\n    self,\n    problem: Problem[ProbInputType, ProbOutputType],\n) -&gt; None:\n    \"\"\"Create a tester object.\n\n    :param problem: The problem to be tested.\n    \"\"\"\n    super().__init__()\n    self._problem: Problem[ProbInputType, ProbOutputType] = problem\n    self._submission: Any | None = None\n    self._submission_context: ContextManager = ContextManager()\n    self._logger = _tester_logger.getChild(\n        f\"Tester_{problem and problem.expected_submission_name}\"\n    )\n</code></pre>"},{"location":"API/tester/#gapper.core.tester.tester_def.Tester.check_context_completeness","title":"check_context_completeness","text":"<pre><code>check_context_completeness() -&gt; None\n</code></pre> <p>Check if the context is complete against what's required in the problem.</p> Source code in <code>src/gapper/core/tester/tester_def.py</code> <pre><code>def check_context_completeness(self) -&gt; None:\n    \"\"\"Check if the context is complete against what's required in the problem.\"\"\"\n    for context_value_name in self.problem.config.captured_context:\n        if context_value_name not in self.submission_context:\n            raise MissingContextValueError(context_value_name)\n\n    self._logger.debug(\"Context completeness check passed\")\n</code></pre>"},{"location":"API/tester/#gapper.core.tester.tester_def.Tester.dump_to","title":"dump_to","text":"<pre><code>dump_to(path: Path | str) -&gt; None\n</code></pre> <p>Dump the tester to a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path | str</code> <p>The path to dump the tester to.</p> required Source code in <code>src/gapper/core/tester/tester_def.py</code> <pre><code>def dump_to(self, path: Path | str) -&gt; None:\n    \"\"\"Dump the tester to a file.\n\n    :param path: The path to dump the tester to.\n    \"\"\"\n    with open(path, \"wb\") as f:\n        dump(self, f)\n\n    _tester_logger.debug(f\"Tester dumped to path {path.absolute()}\")\n</code></pre>"},{"location":"API/tester/#gapper.core.tester.tester_def.Tester.from_file","title":"from_file  <code>classmethod</code>","text":"<pre><code>from_file(path: Path) -&gt; Tester\n</code></pre> <p>Load a tester from a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to load the tester from.</p> required Source code in <code>src/gapper/core/tester/tester_def.py</code> <pre><code>@classmethod\ndef from_file(cls, path: Path) -&gt; Tester:\n    \"\"\"Load a tester from a file.\n\n    :param path: The path to load the tester from.\n    \"\"\"\n    with open(path, \"rb\") as f:\n        tester = ProblemUnpickler(f).load()\n\n    _tester_logger.debug(f\"Tester loaded from path {path.absolute()}\")\n\n    return tester\n</code></pre>"},{"location":"API/tester/#gapper.core.tester.tester_def.Tester.load_context_from_module","title":"load_context_from_module","text":"<pre><code>load_context_from_module(md: ModuleType) -&gt; Self\n</code></pre> <p>Load the context from a module.</p> <p>Parameters:</p> Name Type Description Default <code>md</code> <code>ModuleType</code> <p>The module to load the context from.</p> required <p>Raises:</p> Type Description <code>MultipleContextValueError</code> <p>If multiple context values are found.</p> Source code in <code>src/gapper/core/tester/tester_def.py</code> <pre><code>def load_context_from_module(self, md: ModuleType) -&gt; Self:\n    \"\"\"Load the context from a module.\n\n    :param md: The module to load the context from.\n    :raises MultipleContextValueError: If multiple context values are found.\n    \"\"\"\n    for context_value_name in self.problem.config.captured_context:\n        try:\n            context_value = self._load_symbol_from_module(md, context_value_name)\n        except AttributeError:\n            continue\n\n        if context_value_name in self.submission_context:\n            raise MultipleContextValueError(context_value_name)\n\n        self.submission_context[context_value_name] = context_value\n        self._logger.debug(\n            f\"Loaded context value for {context_value_name} from {md}\"\n        )\n\n    return self\n</code></pre>"},{"location":"API/tester/#gapper.core.tester.tester_def.Tester.load_submission_from_path","title":"load_submission_from_path","text":"<pre><code>load_submission_from_path(path: Path) -&gt; Self\n</code></pre> <p>Load the submission from a path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to load the submission from. If the path is a directory, it will be searched recursively.</p> required <p>Raises:</p> Type Description <code>NoSubmissionError</code> <p>If no submission is found.</p> <code>MultipleSubmissionError</code> <p>If multiple submissions are found.</p> Source code in <code>src/gapper/core/tester/tester_def.py</code> <pre><code>def load_submission_from_path(self, path: Path) -&gt; Self:\n    \"\"\"Load the submission from a path.\n\n    :param path: The path to load the submission from. If the path is a directory, it will be searched recursively.\n    :raises NoSubmissionError: If no submission is found.\n    :raises MultipleSubmissionError: If multiple submissions are found.\n    \"\"\"\n    if self.problem.config.is_script:\n        self._logger.debug(\"Loading script submission\")\n        submission_list = list(self._load_script_submission_from_path(path))\n    else:\n        self._logger.debug(\"Loading object submission\")\n        submission_list = list(self._load_object_submission_from_path(path))\n\n    self._logger.debug(\n        f\"Found {len(submission_list)} submissions: {submission_list}\"\n    )\n\n    if len(submission_list) == 0:\n        raise NoSubmissionError(self.problem.expected_submission_name)\n    elif len(submission_list) &gt; 1:\n        raise MultipleSubmissionError(self.problem.expected_submission_name)\n\n    self._submission = submission_list[0]\n    self._logger.debug(\"Submission loaded\")\n\n    return self\n</code></pre>"},{"location":"API/tester/#gapper.core.tester.tester_def.Tester.run","title":"run","text":"<pre><code>run(metadata: GradescopeSubmissionMetadata | None = None) -&gt; List[TestResult]\n</code></pre> <p>Run the tests.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <code>GradescopeSubmissionMetadata | None</code> <p>The metadata of the submission, which could be None.</p> <code>None</code> Source code in <code>src/gapper/core/tester/tester_def.py</code> <pre><code>def run(\n    self, metadata: GradescopeSubmissionMetadata | None = None\n) -&gt; List[TestResult]:\n    \"\"\"Run the tests.\n\n    :param metadata: The metadata of the submission, which could be None.\n    \"\"\"\n    if self.problem is None:\n        raise InternalError(\"No problem loaded.\")\n\n    if self.submission is None:\n        raise InternalError(\"No submission loaded.\")\n\n    self.check_context_completeness()\n\n    pre_results = self.run_hooks(\n        HookTypes.PRE_TESTS, PreTestsData(metadata=metadata)\n    )\n    test_results = self.run_tests(metadata=metadata)\n    post_test_result = self.run_hooks(\n        HookTypes.POST_TESTS,\n        PostTestsData(test_results=test_results, metadata=metadata),\n    )\n    self.tear_down_hooks(HookTypes.PRE_TESTS)\n    self.tear_down_hooks(HookTypes.PRE_TESTS)\n\n    return [*pre_results, *test_results, *post_test_result]\n</code></pre>"},{"location":"API/tester/#pretests-pre_tests-posttests-and-post_tests-api","title":"<code>PreTests</code>, <code>pre_tests</code>, <code>PostTests</code>, and <code>post_tests</code> API","text":""},{"location":"API/tester/#pretests-and-pre_tests","title":"<code>PreTests</code> and <code>pre_tests</code>","text":"<p>The public tester API.</p>"},{"location":"API/tester/#gapper.core.tester.pre_tests","title":"pre_tests  <code>module-attribute</code>","text":"<pre><code>pre_tests = PreTests\n</code></pre>"},{"location":"API/tester/#gapper.core.tester.post_tests","title":"post_tests  <code>module-attribute</code>","text":"<pre><code>post_tests = PostTests\n</code></pre>"},{"location":"API/tester/#gapper.core.tester.PreTests","title":"PreTests","text":"<p>             Bases: <code>HookBase</code></p> Source code in <code>src/gapper/core/tester/tester_hooks.py</code> <pre><code>class PreTests(HookBase):\n    _hook_type = HookTypes.PRE_TESTS\n</code></pre>"},{"location":"API/tester/#gapper.core.tester.PostTests","title":"PostTests","text":"<p>             Bases: <code>HookBase</code></p> <p>A decorator for post tests. Will be used as @post_tests() decorator.</p> Source code in <code>src/gapper/core/tester/tester_hooks.py</code> <pre><code>class PostTests(HookBase):\n    \"\"\"A decorator for post tests. Will be used as @post_tests() decorator.\"\"\"\n\n    _hook_type = HookTypes.POST_TESTS\n</code></pre>"},{"location":"API/useful_types/","title":"Useful Types","text":""},{"location":"API/useful_types/#api","title":"API","text":""},{"location":"API/useful_types/#gapper.core.types.CustomTestFn","title":"CustomTestFn","text":"<p>             Bases: <code>Protocol</code></p> <p>The function type to be called for custom tests.</p> Source code in <code>src/gapper/core/types.py</code> <pre><code>class CustomTestFn(Protocol):\n    \"\"\"The function type to be called for custom tests.\"\"\"\n\n    def __call__[T](self, data: CustomTestData[T]) -&gt; None:\n        \"\"\"Implement.\n\n        :param data: The CustomTestData instance.\n        :raises AssertionError: It should raise assertion error if test fails.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"API/useful_types/#gapper.core.types.CustomTestFn.__call__","title":"__call__","text":"<pre><code>__call__(data: CustomTestData[T]) -&gt; None\n</code></pre> <p>Implement.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>CustomTestData[T]</code> <p>The CustomTestData instance.</p> required <p>Raises:</p> Type Description <code>AssertionError</code> <p>It should raise assertion error if test fails.</p> Source code in <code>src/gapper/core/types.py</code> <pre><code>def __call__[T](self, data: CustomTestData[T]) -&gt; None:\n    \"\"\"Implement.\n\n    :param data: The CustomTestData instance.\n    :raises AssertionError: It should raise assertion error if test fails.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"API/useful_types/#gapper.core.types.CustomTestData","title":"CustomTestData  <code>dataclass</code>","text":"<p>             Bases: <code>_TCMixin</code>, <code>_SolSubMixin[T]</code></p> Source code in <code>src/gapper/core/types.py</code> <pre><code>@dataclass\nclass CustomTestData[T](_TCMixin, _SolSubMixin[T]):\n    case: TestCaseWrapper\n    result_proxy: TestResult\n    solution: T\n    submission: T\n</code></pre>"},{"location":"API/useful_types/#gapper.core.types.CustomEqualityCheckFn","title":"CustomEqualityCheckFn","text":"<p>             Bases: <code>Protocol</code></p> <p>The function type to be called for custom equality checks.</p> Source code in <code>src/gapper/core/types.py</code> <pre><code>class CustomEqualityCheckFn(Protocol):\n    \"\"\"The function type to be called for custom equality checks.\"\"\"\n\n    def __call__[T](self, data: CustomEqualityTestData[T]) -&gt; None:\n        \"\"\"Implement.\n\n        :param data: The CustomEqualityTestData instance.\n        :raises AssertionError: It should raise assertion error if the equality check tails\n        \"\"\"\n        ...\n</code></pre>"},{"location":"API/useful_types/#gapper.core.types.CustomEqualityCheckFn.__call__","title":"__call__","text":"<pre><code>__call__(data: CustomEqualityTestData[T]) -&gt; None\n</code></pre> <p>Implement.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>CustomEqualityTestData[T]</code> <p>The CustomEqualityTestData instance.</p> required <p>Raises:</p> Type Description <code>AssertionError</code> <p>It should raise assertion error if the equality check tails</p> Source code in <code>src/gapper/core/types.py</code> <pre><code>def __call__[T](self, data: CustomEqualityTestData[T]) -&gt; None:\n    \"\"\"Implement.\n\n    :param data: The CustomEqualityTestData instance.\n    :raises AssertionError: It should raise assertion error if the equality check tails\n    \"\"\"\n    ...\n</code></pre>"},{"location":"API/useful_types/#gapper.core.types.CustomEqualityTestData","title":"CustomEqualityTestData  <code>dataclass</code>","text":"Source code in <code>src/gapper/core/types.py</code> <pre><code>@dataclass\nclass CustomEqualityTestData[T]:\n    expected: T\n    actual: T\n    msg: str | None = field(default=None)\n</code></pre>"},{"location":"API/useful_types/#gapper.core.types.PreHookFn","title":"PreHookFn","text":"<p>             Bases: <code>Protocol</code></p> <p>The function type to be called for post checks all the equality check of a test case.</p> Source code in <code>src/gapper/core/types.py</code> <pre><code>class PreHookFn(Protocol):\n    \"\"\"The function type to be called for post checks all the equality check of a test case.\"\"\"\n\n    def __call__[T](self, data: PreHookData[T]) -&gt; None:\n        \"\"\"Implement.\n\n        :param data: The PreTestHookData instance.\n        :raises AssertionError: It should raise assertion error if the pre hook fails.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"API/useful_types/#gapper.core.types.PreHookFn.__call__","title":"__call__","text":"<pre><code>__call__(data: PreHookData[T]) -&gt; None\n</code></pre> <p>Implement.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>PreHookData[T]</code> <p>The PreTestHookData instance.</p> required <p>Raises:</p> Type Description <code>AssertionError</code> <p>It should raise assertion error if the pre hook fails.</p> Source code in <code>src/gapper/core/types.py</code> <pre><code>def __call__[T](self, data: PreHookData[T]) -&gt; None:\n    \"\"\"Implement.\n\n    :param data: The PreTestHookData instance.\n    :raises AssertionError: It should raise assertion error if the pre hook fails.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"API/useful_types/#gapper.core.types.PreHookData","title":"PreHookData  <code>dataclass</code>","text":"<p>             Bases: <code>HookDataBase</code>, <code>_TCMixin</code>, <code>_SolSubMixin[T]</code></p> Source code in <code>src/gapper/core/types.py</code> <pre><code>@dataclass\nclass PreHookData[T](HookDataBase, _TCMixin, _SolSubMixin[T]):\n    case: TestCaseWrapper\n    result_proxy: TestResult\n    solution: T\n    submission: T\n</code></pre>"},{"location":"API/useful_types/#gapper.core.types.PostHookFn","title":"PostHookFn","text":"<p>             Bases: <code>Protocol</code></p> <p>The function type to be called for post checks all the equality check of a test case.</p> Source code in <code>src/gapper/core/types.py</code> <pre><code>class PostHookFn(Protocol):\n    \"\"\"The function type to be called for post checks all the equality check of a test case.\"\"\"\n\n    def __call__[T](self, data: PostHookData[T]) -&gt; None:\n        \"\"\"Implement.\n\n        :param data: The PostTestHookData instance.\n        :raises AssertionError: It should raise assertion error if the post hook fails.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"API/useful_types/#gapper.core.types.PostHookFn.__call__","title":"__call__","text":"<pre><code>__call__(data: PostHookData[T]) -&gt; None\n</code></pre> <p>Implement.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>PostHookData[T]</code> <p>The PostTestHookData instance.</p> required <p>Raises:</p> Type Description <code>AssertionError</code> <p>It should raise assertion error if the post hook fails.</p> Source code in <code>src/gapper/core/types.py</code> <pre><code>def __call__[T](self, data: PostHookData[T]) -&gt; None:\n    \"\"\"Implement.\n\n    :param data: The PostTestHookData instance.\n    :raises AssertionError: It should raise assertion error if the post hook fails.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"API/useful_types/#gapper.core.types.PostHookData","title":"PostHookData  <code>dataclass</code>","text":"<p>             Bases: <code>HookDataBase</code>, <code>_TCMixin</code>, <code>_SolSubMixin[T]</code>, <code>_SolSubResultMixin[T]</code></p> Source code in <code>src/gapper/core/types.py</code> <pre><code>@dataclass\nclass PostHookData[T](HookDataBase, _TCMixin, _SolSubMixin[T], _SolSubResultMixin[T]):\n    case: TestCaseWrapper\n    result_proxy: TestResult\n    solution: T\n    submission: T\n    expected_results: ResultBundle\n    actual_results: ResultBundle\n</code></pre>"},{"location":"API/useful_types/#gapper.core.types.PreTestsFn","title":"PreTestsFn","text":"<p>             Bases: <code>Protocol</code></p> Source code in <code>src/gapper/core/types.py</code> <pre><code>class PreTestsFn(Protocol):\n    def __call__(self, data: PreTestsData) -&gt; None:\n        \"\"\"Implement.\n\n        :param data: The PreTestsData instance.\n        :raises AssertionError: It should raise assertion error if the pre tests hook fail.\n        \"\"\"\n</code></pre>"},{"location":"API/useful_types/#gapper.core.types.PreTestsFn.__call__","title":"__call__","text":"<pre><code>__call__(data: PreTestsData) -&gt; None\n</code></pre> <p>Implement.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>PreTestsData</code> <p>The PreTestsData instance.</p> required <p>Raises:</p> Type Description <code>AssertionError</code> <p>It should raise assertion error if the pre tests hook fail.</p> Source code in <code>src/gapper/core/types.py</code> <pre><code>def __call__(self, data: PreTestsData) -&gt; None:\n    \"\"\"Implement.\n\n    :param data: The PreTestsData instance.\n    :raises AssertionError: It should raise assertion error if the pre tests hook fail.\n    \"\"\"\n</code></pre>"},{"location":"API/useful_types/#gapper.core.types.PreTestsData","title":"PreTestsData  <code>dataclass</code>","text":"<p>             Bases: <code>HookDataBase</code></p> Source code in <code>src/gapper/core/types.py</code> <pre><code>@dataclass\nclass PreTestsData[T](HookDataBase):\n    result_proxy: TestResult | None = field(default=None)\n    metadata: GradescopeSubmissionMetadata | None = field(default=None)\n</code></pre>"},{"location":"API/useful_types/#gapper.core.types.PostTestsFn","title":"PostTestsFn","text":"<p>             Bases: <code>Protocol</code></p> <p>The function type to be called after all tests are run.</p> Source code in <code>src/gapper/core/types.py</code> <pre><code>class PostTestsFn(Protocol):\n    \"\"\"The function type to be called after all tests are run.\"\"\"\n\n    def __call__(self, data: PostTestsData) -&gt; None:\n        \"\"\"Implement.\n\n        :param data: The PostTestsData instance.\n        :raises AssertionError: It should raise assertion error if the post tests hook fail.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"API/useful_types/#gapper.core.types.PostTestsFn.__call__","title":"__call__","text":"<pre><code>__call__(data: PostTestsData) -&gt; None\n</code></pre> <p>Implement.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>PostTestsData</code> <p>The PostTestsData instance.</p> required <p>Raises:</p> Type Description <code>AssertionError</code> <p>It should raise assertion error if the post tests hook fail.</p> Source code in <code>src/gapper/core/types.py</code> <pre><code>def __call__(self, data: PostTestsData) -&gt; None:\n    \"\"\"Implement.\n\n    :param data: The PostTestsData instance.\n    :raises AssertionError: It should raise assertion error if the post tests hook fail.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"API/useful_types/#gapper.core.types.PostTestsData","title":"PostTestsData  <code>dataclass</code>","text":"<p>             Bases: <code>HookDataBase</code></p> Source code in <code>src/gapper/core/types.py</code> <pre><code>@dataclass\nclass PostTestsData[T](HookDataBase):\n    test_results: List[TestResult]\n    result_proxy: TestResult | None = field(default=None)\n    metadata: GradescopeSubmissionMetadata | None = field(default=None)\n</code></pre>"},{"location":"Contributing/how_to_contribute/","title":"How To Contribute","text":"<p><code>gapper</code> welcomes everyone to contribute to the project. There are many ways to contribute.  You can open up issues when you find bugs or have feature requests. You can also contribute code to the project. This document contains the guidelines for contributing to the project.</p>"},{"location":"Contributing/how_to_contribute/#prerequisite","title":"Prerequisite","text":"<p>We assume you have <code>Python&gt;=3.12</code> and <code>poetry</code> is installed on your computer. </p> Python Version Management <p>We recommend using <code>pyenv</code> to manage your python version.  You can find its installation instructions here</p>"},{"location":"Contributing/how_to_contribute/#setup","title":"Setup","text":"<ol> <li>Fork the repo (https://github.com/FlickerSoul/gapper) to your account.</li> <li>Clone the repo by <code>git clone https://github.com/&lt;your_user_name&gt;/gapper.git</code>.</li> <li>Install dependencies using <code>poetry install</code>.</li> <li>Set up the pre-commit hooks by <code>pre-commit install --hook-type pre-commit --hook-type pre-push</code>. See Code Style.</li> <li>(Optionally but recommended) Install the IDE plugins for <code>ruff</code>:</li> <li>If you're using IDEs from JetBrains, please install the ruff plugin. </li> <li>If you're using vim/neovim, please install the ruff LSP server and enable it.</li> <li>If you're using VSCode, please install the ruff VSCode extension.</li> <li>Write code, commit.</li> <li>Test your code by running <code>pytest tests</code>. See Testing.<ul> <li>Integrations tests like testing CLI commands and GUI can be slow. You can ignore them by adding    <code>--ignore-glob=*integration_test.py</code> flag to your <code>pytest</code> command. </li> <li>Note that some tests require you set up gradescope account details, or otherwise they will be skipped</li> </ul> </li> <li>Push to your account.</li> <li>Open a pull request.</li> </ol>"},{"location":"Contributing/how_to_contribute/#code-style","title":"Code Style","text":"<p>If you have pre-commit hooks installed, you're good to go.  The hooks will automatically check your code style and notify you if something went wrong. </p> <p>If you're using any kind of IDEs, please install the corresponding plugins from the instructions above. </p> <p>We are currently not checking document strings and this will be enforced in the future.</p> <p><code>gapper</code> uses <code>ruff</code> as the formatter and linter.  The configuration is encoded in the <code>pyproject.toml</code> located under the root of this project. You should run  <code>ruff src tests</code> to lint the style of your code, and use <code>ruff format src tests</code> to format your code.  You might be prompt to use the <code>--fix</code> flag to auto-fix some of the problems, and please do when you find so. </p>"},{"location":"Contributing/how_to_contribute/#testing","title":"Testing","text":"<p>Testing is done using <code>pytest</code> and several extensions include <code>pytest-mock</code>, <code>pytest-asyncio</code>, and <code>pytest-cov</code>. </p> <p>As mentioned above, some integrations can be slow to test, including CLI testing and GUI testing. You can find those  integrations by searching <code>*integration_test.py</code> in the project directory. </p> <p>The pre-commit hook ignores integration tests when you commit, but checks them when you push. This helps us do quick  commits without waiting for testing while ensuring code qualities. This implies two things: </p> <ol> <li>You have to pass tests before committing/pushing.</li> <li>Please do not include lengthy tests into the commit hook, as this will cost developers time. </li> </ol>"},{"location":"Examples/","title":"Examples","text":""},{"location":"Examples/#from-testing","title":"From Testing","text":"<p>There are a number of problem examples are located here in the testing asset directory. You can find the solutions to these problems here.</p>"},{"location":"Examples/#more-examples","title":"More Examples","text":"<p>They will be put here once they are created.</p>"},{"location":"Tutorials/Detailed-Usage/","title":"Detailed Usage","text":"<p>We will discuss the detailed usage of <code>gapper</code>, including installation, CLI commands, how to create a problem, and how to construct test cases. </p>"},{"location":"Tutorials/Detailed-Usage/#installation","title":"Installation","text":"<p>The python version required is <code>&gt;=3.12.0</code>. </p> <p>You can either install from PyPI <pre><code>pip install gapper~=1.3.0\n</code></pre></p> <p>or install using poetry <pre><code>poetry add gapper~=1.3.0\n</code></pre></p> <p>or install from source <pre><code>git clone https://github.com/FlickerSoul/gapper.git\npip install -e gapper\n</code></pre></p>"},{"location":"Tutorials/Detailed-Usage/#prerequisite","title":"Prerequisite","text":"<p>You need a solution to the assignment for which you'd like to create a autograder, no matter it being a function, or a class. </p> <p>If you want a brief of the whole process, please refer to the workflow brief in the home page. </p>"},{"location":"Tutorials/Detailed-Usage/#command-line-interface","title":"Command Line Interface","text":"<p>Once <code>gapper</code> is installed, you can invoke it through either <code>gap</code>, <code>gapper</code>, or <code>gradescope-autograder-packer</code>. </p> \u276f gapper --help <pre><code>\u276f gapper --help\n\nUsage: gapper [OPTIONS] COMMAND [ARGS]...\n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --install-completion        [bash|zsh|fish|powershell|pwsh]  Install completion for the specified shell.                \u2502\n\u2502                                                              [default: None]                                            \u2502\n\u2502 --show-completion           [bash|zsh|fish|powershell|pwsh]  Show completion for the specified shell, to copy it or     \u2502\n\u2502                                                              customize the installation.                                \u2502\n\u2502                                                              [default: None]                                            \u2502\n\u2502 --help                                                       Show this message and exit.                                \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Commands \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 check              Check if the problem is defined correctly again the gap_check fields.                                \u2502\n\u2502 gen                Generate the autograder for a problem.                                                               \u2502\n\u2502 login              Login to Gradescope.                                                                                 \u2502\n\u2502 run                Run the autograder on an example submission.                                                         \u2502\n\u2502 run-in-prod        Run the autograder in production mode.                                                               \u2502\n\u2502 upload                                                                                                                  \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> \u276f gapper check --help <pre><code>\u276f gapper check --help\n\n Usage: gapper check [OPTIONS] PATH\n\n Check if the problem is defined correctly again the gap_check fields.\n\n\u256d\u2500 Arguments \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 *    path      PATH  The path to the problem python file. [default: None] [required]                                    \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --auto-inject  -a            Whether to auto inject the tester file. [default: (dynamic)]                               \u2502\n\u2502 --inject       -i      PATH  The path to the tester file to inject. [default: (dynamic)]                                \u2502\n\u2502 --verbose      -v            Whether to run in verbose mode.                                                            \u2502\n\u2502 --help                       Show this message and exit.                                                                \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> \u276f gapper gen --help <pre><code>\u276f gapper gen --help\n\n Usage: gapper gen [OPTIONS] PATH\n\n Generate the autograder for a problem.\n\n\u256d\u2500 Arguments \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 *    path      PATH  The path to the problem python file. [default: None] [required]                                    \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --save-path          -s      PATH  The directory to save the generated tester file. [default: (dynamic)]                \u2502\n\u2502 --auto-inject        -a            Whether to auto inject the tester file. [default: (dynamic)]                         \u2502\n\u2502 --inject             -i      PATH  The path to the tester file to inject. [default: (dynamic)]                          \u2502\n\u2502 --confirm-overwrite  -y            Confirm overwrite files.                                                             \u2502\n\u2502 --verbose            -v            Whether to run in verbose mode.                                                      \u2502\n\u2502 --upload             -u            Whether to upload the autograder.                                                    \u2502\n\u2502 --gui                -g            Whether to use the GUI to upload.                                                    \u2502\n\u2502 --login-save-path    -l      PATH  The path to save the login info.                                                     \u2502\n\u2502                                    [default: /Users/flicker_soul/.config/gapper/gs_account.yaml]                        \u2502\n\u2502 --ui-debug           -d            Whether to run in verbose mode.                                                      \u2502\n\u2502 --help                             Show this message and exit.                                                          \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> \u276f gapper login --help <pre><code>\u276f gapper login --help\n\n Usage: gapper login [OPTIONS]\n\n Login to Gradescope.\n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --confirm-store      -s            Confirm storing your login info.                                                     \u2502\n\u2502 --confirm-overwrite  -y            Confirm overwrite files.                                                             \u2502\n\u2502 --login-save-path    -l      PATH  The path to save the login info.                                                     \u2502\n\u2502                                    [default: /Users/flicker_soul/.config/gapper/gs_account.yaml]                        \u2502\n\u2502 --verbose            -v            Whether to run in verbose mode.                                                      \u2502\n\u2502 --help                             Show this message and exit.                                                          \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> \u276f gapper run --help <pre><code>\u276f gapper run --help\n\n Usage: gapper run [OPTIONS] PATH SUBMISSION\n\n Run the autograder on an example submission.\n\n\u256d\u2500 Arguments \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 *    path            PATH  The path to the problem python file. [default: None] [required]                              \u2502\n\u2502 *    submission      PATH  The path to the submission file. [default: None] [required]                                  \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --metadata     -m      FILE   The path to the submission metadata file. [default: (dynamic)]                            \u2502\n\u2502 --auto-inject  -a             Whether to auto inject the tester file. [default: (dynamic)]                              \u2502\n\u2502 --inject       -i      PATH   The path to the tester file to inject. [default: (dynamic)]                               \u2502\n\u2502 --verbose      -v             Whether to run in verbose mode.                                                           \u2502\n\u2502 --total-score          FLOAT  [default: 20]                                                                             \u2502\n\u2502 --help                        Show this message and exit.                                                               \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> \u276f gapper run-in-prod --help <pre><code>\u276f gapper run-in-prod --help\n\n Usage: gapper run-in-prod [OPTIONS] [TESTER_PATH] [SUBMISSION_DIR]\n                           [METADATA_FILE] [OUTPUT_FILE]\n\n Run the autograder in production mode.\n\n\u256d\u2500 Arguments \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502   tester_path         [TESTER_PATH]     The path to the tester pickle file. [default: /autograder/source/tester.pckl]   \u2502\n\u2502   submission_dir      [SUBMISSION_DIR]  The path to the submission directory. [default: /autograder/submission]         \u2502\n\u2502   metadata_file       [METADATA_FILE]   The path to the submission metadata file.                                       \u2502\n\u2502                                         [default: /autograder/submission_metadata.json]                                 \u2502\n\u2502   output_file         [OUTPUT_FILE]     The path to the output file. [default: /autograder/results/results.json]        \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --verbose  -v        Whether to run in verbose mode. [default: True]                                                    \u2502\n\u2502 --help               Show this message and exit.                                                                        \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> \u276f gapper upload --help <pre><code>\u276f gapper upload --help\n\n Usage: gapper upload [OPTIONS] COMMAND [ARGS]...\n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --help          Show this message and exit.                                                                             \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Commands \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 gui      Upload an autograder to Gradescope with GUI.                                                                   \u2502\n\u2502 ids      Upload an autograder to Gradescope using the cid and aid.                                                      \u2502\n\u2502 url      Upload an autograder to Gradescope using the assignment url.                                                   \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> \u276f gapper upload gui --help <pre><code>\u276f gapper upload gui --help\n\n Usage: gapper upload gui [OPTIONS] AUTOGRADER_PATH\n\n Upload an autograder to Gradescope with GUI.\n\n\u256d\u2500 Arguments \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 *    autograder_path      PATH  The path to the autograder zip file. [default: None] [required]                         \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --login-save-path  -l      PATH  The path to save the login info.                                                       \u2502\n\u2502                                  [default: /Users/flicker_soul/.config/gapper/gs_account.yaml]                          \u2502\n\u2502 --ui-debug         -d            Whether to run in verbose mode.                                                        \u2502\n\u2502 --help                           Show this message and exit.                                                            \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> \u276f gapper upload ids --help <pre><code>\u276f gapper upload ids --help\n\n Usage: gapper upload ids [OPTIONS] AUTOGRADER_PATH [CID] [AID]\n\n Upload an autograder to Gradescope using the cid and aid.\n\n\u256d\u2500 Arguments \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 *    autograder_path      PATH   The path to the autograder zip file. [default: None] [required]                        \u2502\n\u2502      cid                  [CID]  The course id. [default: None]                                                         \u2502\n\u2502      aid                  [AID]  The assignment id. [default: None]                                                     \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --login-save-path  -l      PATH  The path to save the login info.                                                       \u2502\n\u2502                                  [default: /Users/flicker_soul/.config/gapper/gs_account.yaml]                          \u2502\n\u2502 --ui-debug         -d            Whether to run in verbose mode.                                                        \u2502\n\u2502 --help                           Show this message and exit.                                                            \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> \u276f gapper upload url --help <pre><code>\u276f gapper upload url --help\n\n Usage: gapper upload url [OPTIONS] AUTOGRADER_PATH ASSIGNMENT_URL\n\n Upload an autograder to Gradescope using the assignment url.\n\n\u256d\u2500 Arguments \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 *    autograder_path      PATH  The path to the autograder zip file. [default: None] [required]                         \u2502\n\u2502 *    assignment_url       TEXT  The url to the autograder. [default: None] [required]                                   \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --login-save-path  -l      PATH  The path to save the login info.                                                       \u2502\n\u2502                                  [default: /Users/flicker_soul/.config/gapper/gs_account.yaml]                          \u2502\n\u2502 --ui-debug         -d            Whether to run in verbose mode.                                                        \u2502\n\u2502 --help                           Show this message and exit.                                                            \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>"},{"location":"Tutorials/Detailed-Usage/#glossary","title":"Glossary","text":"<ul> <li>An <code>assignment</code> refers to the assignment issued to students, and is often created as one GradeScope assignment entry. </li> <li>A <code>solution</code> refers to the code that solves the assignment. </li> <li>A <code>problem</code> refers to the definition of an assignment in the autograder. It can be created with the <code>@problem</code> decorator. </li> <li>A <code>test case</code> refers to one test entry in the GradeScope assignment entry. It can be created with the <code>@test_case</code> decorator.  </li> <li><code>test cases</code> refer to a group of <code>test case</code>s. They can be created in batch with the <code>@test_cases</code> decorator. </li> </ul>"},{"location":"Tutorials/Detailed-Usage/#create-a-problem","title":"Create A Problem","text":"<p>We first import <code>problem</code> from <code>gapper</code> and apply it as an decorator. Examples are provided at the end of this section. </p> <pre><code>from gapper import problem\n\n@problem()\ndef ...\n</code></pre> <p>The <code>problem</code> has two over loads: </p> <p><pre><code>is_script: bool = False\ncontext: Iterable[str] = ()\neasy_context: bool = True\n</code></pre> and  <pre><code>check_stdout: Optional[bool] = None\nmock_input: Optional[bool] = None\ncontext: Iterable[str] = ()\neasy_context: bool = True\n</code></pre></p> <p><code>is_script</code> is used to indicate if the assignment is a script, which is something like the following </p> <p><pre><code>i = input(\"give me a number: \")\nprint(f\"the square of the number is {i ** 2}\")\n</code></pre> Leaving the <code>is_script</code> to <code>False</code>, the <code>@problem()</code> decorator treat decorated entity without extra interpretation. </p> <p><code>check_stdout</code> asks the autograder to compare stdout output (e.g. from the <code>print</code> function)</p> <p><code>mock_input</code> feeds test case arguments into <code>input</code> call when the submission is run. </p> <p><code>context</code> is used to capture variables in submissions. Please see (Easy) Context for more details.</p>"},{"location":"Tutorials/Detailed-Usage/#extra-things","title":"Extra Things","text":"<p>You can add <code>@gs_connect</code> decorator anywhere above the <code>@problem</code> to support automatic autograder upload.  Please refer to this page for more details.</p>"},{"location":"Tutorials/Detailed-Usage/#examples","title":"Examples","text":"<ul> <li>Example 1, autograder sees script  <p>Problem: <pre><code>@problem(is_script=True)\ndef distance():\n    x1 = float(input(\"Location x-coordinate? \"))\n    y1 = float(input(\"Location y-coordinate? \"))\n    x2 = float(input(\"Classroom x-coordinate? \"))\n    y2 = float(input(\"Classroom y-coordinate? \"))\n    dx = x2-x1\n    dy = y2-y1\n    d = (dx*dx+dy*dy)**0.5\n    print(\"Distance:\")\n    print(d)\n</code></pre> Submission: <pre><code>x1 = float(input(\"Location x-coordinate? \"))\ny1 = float(input(\"Location y-coordinate? \"))\nx2 = float(input(\"Classroom x-coordinate? \"))\ny2 = float(input(\"Classroom y-coordinate? \"))\ndx = x2-x1\ndy = y2-y1\nd = (dx*dx+dy*dy)**0.5\nprint(\"Distance:\")\nprint(d)\n</code></pre></p> </li> <li>Example 2, autograder sees a function  <p>Problem:  <pre><code>@problem()\ndef coins(cents):\n    q = cents // 25\n    cents = cents % 25\n    d = cents // 10\n    cents = cents % 10\n    n = cents // 5\n    p = cents % 5\n    return q + d + n + p\n</code></pre> Submission: <pre><code>def coins(cents):\n    q = cents // 25\n    cents = cents % 25\n    d = cents // 10\n    cents = cents % 10\n    n = cents // 5\n    p = cents % 5\n    return q + d + n + p\n</code></pre></p> </li> <li>Example 3, autograder sees a class  <p>Problem:  <pre><code>@problem()\nclass LinkedList:\n    ...\n</code></pre> Submission:  <pre><code>class LinkedList:\n    ...\n</code></pre></p> </li> </ul>"},{"location":"Tutorials/Detailed-Usage/#create-test-cases","title":"Create test case(s)","text":"<p>You can import <code>test_case</code> and <code>test_cases</code> to help the generation of tests. The two helpers are treated as decorators and should be applied after the <code>@problem()</code> decorator. For example, </p> <pre><code>from gapper import problem, test_case, test_cases, param\n\n@test_cases.param_iter((i, i + 1) for i in range(10))\n@test_cases.params([1, 2], param(1, b=1), param(1, b=3))\n@test_case(1, b=4)\n@problem()\ndef fn(a, b):\n    ...\n</code></pre> <p>Note that, we have shorter aliases for <code>test_case</code> and <code>test_cases</code>, which are <code>tc</code> and <code>tcs</code> respectively.</p> <pre><code>from gapper import tc, tcs, test_case, test_cases\n\nassert tc is test_case\nassert tcs is test_cases\n</code></pre>"},{"location":"Tutorials/Detailed-Usage/#specify-parameters","title":"Specify Parameters","text":"<p>Given a function <code>def fn()</code>, arguments specified in <code>@test_case()</code> will be unfolded to parameters of fn when testing. That is, for instance, the input of <code>a</code>, <code>args</code>, <code>kw=1</code>, and <code>kwargs</code> in <code>@test_case(a, *args, kw=1, **kwargs)</code> will result in <code>fn(a, *args, kw=1, **kwargs)</code> when testing. </p> <p>When using <code>@test_cases()</code> one has to choose a flavor of <code>test_cases</code> before proceeding. The options currently are <code>params</code>, <code>param_iter</code>, <code>singular_params</code>, and <code>singular_param_iter</code>. To use choose the option, one specify by using <code>@test_cases.&lt;option&gt;()</code>. For example, <code>@test_cases.params()</code>. Depending on the option, you can usually pass either <code>Iterable</code>s or <code>param</code>s as arguments to the decorator <code>@test_cases()</code>. For example, <code>@test_cases.params([1, 2], param(3, b=4))</code>. Note that <code>param</code> is the preferred way to define test cases since it is equivalent to <code>@test_case</code> semantically. </p> <p>The following is the explanation of the effect of each option. </p> <ul> <li><code>params</code> takes in any number of <code>Sequence</code> or <code>param</code>. Each <code>Sequence</code> or <code>param</code> is equivalent to specifying a <code>@test_case()</code>. For example, <code>@test_cases.params([1, 2], param(1, b=1))</code> is equivalent to specifying two tests cases, <code>@test_case(1, 2)</code> and <code>@test_case(1, b=1)</code>. </li> <li><code>param_iter</code> takes in a <code>Iterable</code> object of <code>Sequence</code> or <code>param</code>. <code>@test_cases.param_iter(iter)</code> is equivalent to <code>@test_cases.params(*iter)</code>. For example, </li> </ul> <p><pre><code>iter = ([i, i + 1] for i in range(1, 3))\n@test_cases.param_iter(iter)\ndef fn(a, b):\n  ...\n...\n</code></pre>   is equivalent to    <pre><code>@test_cases.params([1, 1 + 1], [2, 2 + 1])\n</code></pre> - <code>singular_params</code> is similar to <code>params</code> except it does not unfold <code>Sequence</code> like <code>params</code>. That is, <code>@test_cases.singular_params([1, 2], param(1, b=1))</code> is equivalent to specifying two tests cases, <code>@test_case([1, 2])</code> and <code>@test_case(1, b=1)</code>. - <code>singular_param_iter</code> is similar to <code>param_iter</code>. <code>@test_cases.singular_param_iter(iter)</code> is equivalent to <code>@test_cases.singular_params(*iter)</code>. </p>"},{"location":"Tutorials/Detailed-Usage/#specify-test-options","title":"Specify Test Options","text":"<p>You can configure test cases' properties by using keyword arguments start with <code>gap_</code>. For each test case, the supported options are </p> <pre><code>gap_expect: Any | Sequence[Any] | None = None,\ngap_expect_stdout: str | Sequence[str] | None = None,\ngap_hidden: bool | Sequence[bool] = False,\ngap_name: str | Sequence[str] | None = None,\ngap_extra_points: float | Sequence[float] | None = None,\ngap_override_check: CustomEqualityCheckFn\n| Sequence[CustomEqualityCheckFn]\n| None = None,\ngap_easy_context: bool | Sequence[bool] = False,\ngap_override_test: CustomTestFn | Sequence[CustomTestFn] | None = None,\ngap_post_hooks: List[List[PostHookFn]]\n| List[PostHookFn]\n| PostHookFn\n| None = None,\ngap_pre_hooks: List[List[PreHookFn]]\n| List[PreHookFn]\n| PreHookFn\n| None = None,\ngap_description: str | Iterable[str] | Sequence[Iterable[str]] | None = None,\ngap_is_pipeline: bool | Sequence[bool] = False,\ngap_max_score: float | Sequence[float] | None = None,\ngap_weight: float | Sequence[float] | None = None,\n</code></pre> <p>We will dedicate a page to discuss their usages. gap_ Keywords</p>"},{"location":"Tutorials/Detailed-Usage/#run-something-before-and-after-all-the-tests","title":"Run Something Before and After All The Tests","text":"<p>You can add <code>@pre_tests</code> and <code>@post_tests</code> decorators anywhere above the <code>@problem</code> decorator. These decorators  help you setup functions run before and after all the tests respectively. Suppose you want to setup some files used in testing, you can do it with <code>@pre_tests</code>. For example, </p> <pre><code>from gapper import problem, pre_tests, post_tests, tcs\nfrom pathlib import Path\nfrom tempfile import TemporaryDirectory\n\nfrom typing import List\n\nfiles: List[Path] = []\ntmp_dir: Path | None = None\n\ndef create_files(num_of_files: int, directory: Path) -&gt; None:\n    for i in range(num_of_files):\n        path = directory / f\"file_{i}.txt\"\n        with open(path, \"w\") as f:\n            f.write(\"hello world\")\n        files.append(path)\n\ndef pre_test_hook(_) -&gt; None:\n    global tmp_dir\n    with TemporaryDirectory(delete=False) as temporary:\n        tmp_dir = Path(tmp_dir)\n        create_files(10, tmp_dir)\n\n\ndef post_test_hook(_) -&gt; None:\n      global tmp_dir\n      assert tmp_dir is not None \n      tmp_dir.rmdir()\n\n\n@tcs.singular_param_iter(files)\n@pre_tests(pre_test_hook, as_test_case=False)\n@post_tests(post_test_hook, as_test_case=False)\n@problem()\ndef count_lines(in_file: Path) -&gt; int:\n    with open(in_file) as f:\n        return len(f.readlines())\n</code></pre> <p>The functions passed <code>pre_tests</code> and <code>post_tests</code> support yield syntax, similar to <code>gap_pre_hooks</code> and <code>gap_post_hooks</code>.</p> <p>For example, the <code>pre_test_hook</code> and <code>post_test_hook</code> in the code above can be merged into one </p> <pre><code>from gapper import problem, pre_tests, tcs\nfrom pathlib import Path\nfrom tempfile import TemporaryDirectory\n\nfrom typing import List\n\nfiles: List[Path] = []\n\n\ndef create_files(num_of_files: int, directory: Path) -&gt; None:\n  ...\n\n\ndef pre_test_hook(_) -&gt; None:\n    with TemporaryDirectory() as tmp_dir:\n        create_files(10, Path(tmp_dir))\n\n        # everything above yield will be run before all the tests\n        yield \n        # everything below yield all be run after running pre tests, the actual tests\n        # and all post tests\n        # in this case, the code after yield exists the with block, so the temporary\n        # directory will be safely deleted, for this is the moment when all tests are done\n\n\n@tcs.singular_param_iter(files)\n@pre_tests(pre_test_hook, as_test_case=False)\n@problem()\ndef count_lines(in_file: Path) -&gt; int:\n    ...\n</code></pre> <p>The <code>as_test_case</code> argument in <code>pre_tests</code> and <code>post_tests</code> is used to indicate if the function should be treated as a test case.  If <code>as_test_case</code> is <code>True</code>, a test result will be created for that specific <code>pre_tests</code> or <code>post_tests</code> run, and will be counted  towards the total score and display in gradescope, just like a test case. </p>"},{"location":"Tutorials/Detailed-Usage/#examples_1","title":"Examples","text":"<p>You can notice that the <code>@test_case</code> and <code>@test_cases</code> decorators take in parameters that should be passed into the function under test. </p> <pre><code>from gapper import problem, test_case, test_cases\n\n@test_cases.params([5, 6], [7, 8])  # test_cases is a decorator that takes in a list of test cases\n@test_case(3, 4)                    # test_case is a decorator that takes in a single test case\n@test_case(1, 2)                    # they together generate 4 tests, where the parameters are \n@problem()                          # x=1,y=2; x=3,y=4; x=5,y=6; x=7,y=8\ndef add(x: int, y: int) -&gt; int:\n    return x + y\n</code></pre> <p>The following are several ways to specify test cases. </p> <p>This is how you can specify a test cases with one iterable parameter.</p> <pre><code>from gapper import problem, test_cases, param\nfrom typing import Iterable, Generator\nimport random\n\ndef randomly_generate_numbers(times: int) -&gt; Generator[param, None, None]:\n    for _ in range(times):\n        yield param([random.randint(0, 100) for _ in range(random.randint(0, 100))])\n\n@test_cases.param_iter(randomly_generate_numbers(10), gap_max_score=1) # the first two lines have the same semantics, which is creating \n@test_cases.params(*randomly_generate_numbers(10), gap_max_score=1)     # 10 random generated numbers, each worth 1 point \n@test_cases.params(param([1, 2]), param([3, 4], gap_max_score=2))       # `param` is a helper that allows you to specify parameters, in a more \n@test_cases.params([[5, 6]], [[7, 8]], gap_hidden=[True, False])        # readable way. This problem has 6 test cases, where the parameters \n@problem()                                                              # are [1,2]; [3,4]; [5,6]; [7,8]. The three ways of specifying \ndef sum_many(args: Iterable[int]) -&gt; int:                               # parameters are equivalent. Note that @test_cases.params([5, 6], [7, 8])  \n    return sum(args)                                                    # doesn't work because will treat [x, y] as two parameters instead of a list.\n</code></pre> <p>This is how you can specify a test cases with keyword arguments.</p> <pre><code>from gapper import problem, test_cases, test_case, param\n\n@test_cases(param(0, x = 1, y = 2), param(3, x = 4, y = 5))  # You can also specify kwargs in the param or test_case \n@test_case(6, x = 7, y = 8)                                  # decorator. Note that using param is the only way to \n@test_case(9, x = 10)                                        # specify kwargs in test_cases.\n@problem()                                                   \ndef add(a: int, x: int, y: int = 20) -&gt; int:\n    return a * x + y\n</code></pre> <p>This is how you can override the equality check between the solution and the submission.</p> <pre><code>from gapper import problem, test_cases, test_case  \nfrom gapper.core.types import CustomEqualityTestData\nfrom typing import Iterable\n\ndef override_check(data: CustomEqualityTestData) -&gt; None:\n    assert set(data.expected) == set(data.actual)\n\n@test_cases(11, 12, 13, gap_override_check=override_check)\n@test_case(10, gap_override_check=override_check)\n@problem()\ndef generate_numbers(x: int) -&gt; Iterable[int]:\n    return range(x)\n</code></pre> <p>This is how you can override how the submission should be tested.</p> <pre><code>from gapper import problem, test_case, test_cases\nfrom gapper.core.types import CustomTestData\n\n\ndef override_test(data: CustomTestData):\n    solution_answer = data.solution(*data.case.test_param.args)\n    student_answer = data.submission(*data.case.test_param.args)\n    data.case.assertEqual(solution_answer, student_answer)\n\n    data.result_proxy.set_pass_status(\"failed\")\n\n\n@test_cases([3, 4], [5, 6], gap_override_test=override_test)\n@test_case(1, 2, gap_override_test=override_test)\n@problem()\ndef add(x: int, y: int) -&gt; int:\n    if x &lt; 0 or y &lt; 0:\n        raise ValueError(\"x and y must be positive\")\n    return x + y\n</code></pre>"},{"location":"Tutorials/Easy-Context/","title":"(Easy) Context","text":"<p>Sometimes, you might want to capture some definitions in students' submissions for testing purposes. For example, suppose student writes a class <code>Car</code> that uses their definition of <code>GasStation</code>. You might want to reference the <code>GasStation</code> class when overriding tests. </p> <p>Note that you can access captured context only in the <code>gap_override_test</code> and any tests' pre hooks or post hooks. </p>"},{"location":"Tutorials/Easy-Context/#learn-by-example","title":"Learn by Example","text":"<p>Suppose we are creating a problem that asks students to implement a function <code>add</code> that adds two numbers, using a given <code>adder</code> function.  The required <code>adder</code> implementation is add two numbers and mod the result by 10. Below, we first define the golden solution adder named <code>my_adder</code>, and a custom testing  function <code>custom_test</code> that uses the captured context, and the problem solution where the context is specified.</p> <pre><code>from gapper import problem, test_case, test_cases\nfrom gapper.core.types import CustomTestData\n\nfrom typing import Callable\n\n\n# my_adder is a solution adder defined along with the solution\ndef my_adder(a, b) -&gt; int:\n    return a + b % 10\n\n\n# variable `adder` is not defined here, this is just a type hint\n# the name `adder` will be specified in the context to be captured \n# see the last comment in this code\n# and the name `adder` will become available to custom override\n# testing function or the pre-/post-hooks\nadder: Callable[[int, int], int]\n\n\n# custom test that uses the captured context\ndef custom_test(data: CustomTestData):\n    assert my_adder(*data.args) == adder(*data.args)  # notice here\n    # adder is not defined, but we can use it\n    # this is because it will be captured from students' submission context\n\n    # test if student's adder behaves the same in the solution as in their submission\n    assert data.solution(*data.args, adder) == data.submission(\n        *data.args,\n        data.case.context.adder,  # case.context.adder is the same as adder\n    )\n\n\n@test_cases.param_iter(([i, i + 1] for i in range(10)), gap_override_test=custom_test)\n@test_case(1, 2, gap_override_test=custom_test)\n# we specify the name of the context to be captured\n# easy_context is the flag that allows `add` to be used even though it's not defined\n@problem(context=[\"adder\"], easy_context=True)\ndef add(a: int, b: int, the_adder: Callable[[int, int], int]) -&gt; int:\n    return the_adder(a, b)\n</code></pre> <p>Thus if the student's submission is </p> <pre><code>def adder(a, b):\n    return (a % 10 + b % 10) % 10\n\ndef add(a, b, some_adder):\n    return some_adder(a, b)\n</code></pre> <p>The test will pass because the student's <code>adder</code> is semantically equivalent to the solution's <code>my_adder</code>.</p> <p>The <code>easy_context</code> flag, which is set to <code>True</code> by default, in the <code>@problem</code> decorator allows you to inject context variables directly. In the example above, you can use <code>add</code> even though it's not defined. If <code>easy_context</code> is set to False, you can still access the captured context using <code>case.context.&lt;context_variable_name&gt;</code>. For example, <code>case.context.adder</code></p> <p>If any of the names specified in <code>context</code> is not present in student's submission, the submission will be rejected without testing. </p> <p>That is, in the example above, if the student's submission is </p> <p><pre><code>def add(a, b):\n    return (a % 10 + b % 10) % 10\n</code></pre> , because the file does not contain <code>adder</code>, it will be rejected. </p>"},{"location":"Tutorials/Getting-Started/","title":"Getting Started","text":"<p>Welcome to <code>gapper</code> wiki. Here you can find how to use gapper and how to contribute to gapper. This project is inspired by aga and some core code is took from my contribution to the <code>aga</code> project. </p> <p>If you're looking for API references, please visit this page</p>"},{"location":"Tutorials/Getting-Started/#why-gapper-and-who-might-find-it-helpful","title":"Why <code>gapper</code> And Who Might Find It Helpful.","text":"<p><code>gapper</code> is created to facilitate creating autograders for the GradeScope platform. The official tool recommended by GradeScope is <code>gradescope-utils</code>. However, this tool requires users to write cumbersome <code>unittest</code> test cases like the following: </p> <pre><code>class TestSimpleArithmetic(unittest.TestCase):\n    def setUp(self):\n        self.calc = Calculator()\n\n    @weight(1)\n    def test_eval_add(self):\n        \"\"\"Evaluate 1 + 1\"\"\"\n        val = self.calc.eval(\"1 + 1\")\n        self.assertEqual(val, 2)\n</code></pre> <p>Considering professors and teaching assistants usually provide their solutions to students, we created <code>gapper</code> to help them create graders directly and easily from the solutions, without writing boilerplates and test cases from the ground up. For example, the code above can be expressed as the following with the help from <code>gapper</code>:</p> <pre><code>from gapper import problem, test_case\nfrom gapper.core.pipeline_support import Constructor, Function, Property\n\ninit = Constructor()\neval = Function(\"eval\")\n\n@test_case.pipeline(init(), eval(\"1 + 1\"))\n@problem()\nclass Calculator:\n    \"\"\"The calculator solution.\"\"\"\n</code></pre> <p>Note that we designed <code>gapper</code> to handle simple workflow, such as testing a single function, a single class, etc. You can adapt <code>gapper</code> to more complicated workflow by overriding test processes using <code>gap_override_test</code> which will be covered in a separate post. </p> <p>If you're interested, please check out the following workflow brief. </p>"},{"location":"Tutorials/Getting-Started/#workflow-brief","title":"Workflow Brief","text":""},{"location":"Tutorials/Getting-Started/#python-requirement","title":"Python Requirement","text":"<p>You're assumed to have installed Python 3.12.0 or above. If not, please checkout the following dropdown box for more information. </p> Python Version Management <p>The minimal Python version required by <code>gapper</code> is 3.12.0. We recommend <code>pyenv</code> for Python version management for several reasons: </p> <ol> <li>easy install and remove </li> <li>uses <code>shim</code> to switch versions painlessly</li> </ol> <p>If you're using <code>conda</code>, please reference its manual for python version and dependency management.</p> <ul> <li>go to pyenv installation page and follow the install instructions. Note that you might need to manually add <code>pyenv</code> into your system PATH.</li> </ul> <p>Quick pyenv recipes:</p> <ul> <li><code>pyenv versions</code> to check out the installed Python versions and the currently using version.</li> <li><code>pyenv install --list</code> lists all available Python versions to be installed.</li> <li><code>pyenv install &lt;python-version&gt;</code> to install a specific Python version. For example, <code>pyenv install 3.12.0</code>.</li> <li><code>pyenv global &lt;python-version&gt;</code> to set the global Python version. For example, <code>pyenv global 3.12.0</code>. After calling <code>pyenv global &lt;version&gt;</code>, the <code>python</code> and <code>python3</code> commands will now be the version you specified. </li> <li>After using the python for this project, you can switch back to your original Python version by calling <code>pyenv global &lt;original-version&gt;</code>.</li> </ul>"},{"location":"Tutorials/Getting-Started/#gapper-installation","title":"Gapper Installation","text":"<p>We recommend creating a virtual environment for your packages. If you're not familiar with virtual environment, please check out the following dropdown box for more information.</p> Virtual Environment <p>Virtual environment is a tool that helps you manage your Python packages. <code>pip install &lt;package&gt;</code> installs the package globally, meaning if you have two projects requiring the same package but different version, <code>pip install</code> will get you in trouble. </p> <p>If you're using <code>conda</code>, you can create a virtual environment by calling <code>conda create -n &lt;env-name&gt; python=&lt;python-version&gt;</code>. For example, <code>conda create -n gapper python=3.12.0</code>. You can activate the virtual environment by calling <code>conda activate &lt;env-name&gt;</code>. For example, <code>conda activate gapper</code>. You can deactivate the virtual environment by calling <code>conda deactivate</code>. And you can reuse the virtual environment by calling <code>conda activate &lt;env-name&gt;</code> again.</p> <p>The easiest way to create a virtual environment is to use <code>venv</code> module. </p> <pre><code>python3 -m venv &lt;path-to-venv&gt;\n</code></pre> <p>Usually, we use it as the following. </p> <pre><code># install virtual environment in the under the venv folder in the current working directory\npython3 -m venv ./venv\n# this ignores the venv folder in git. feel free to ignore it if you're not familiar with git.\necho \"venv/\" &gt;&gt; .gitignore  \n</code></pre> <p>After creating the virtual environment, you can activate it by calling  <pre><code>source &lt;path-to-venv&gt;/bin/activate\n</code></pre></p> <p>For example, accompanying the previous example, </p> <pre><code>source ./venv/bin/activate\n</code></pre> <p>After activating the virtual environment, you can install packages using <code>pip install &lt;package&gt;</code> as usual.  <code>pip</code> will install the packages under the <code>venv</code> folder and will not affect any other projects.  Once you're done with the project, you can deactivate the virtual environment by calling <code>deactivate</code>. </p> <pre><code>deactivate\n</code></pre> <p>If you want to use gapper and thus the virtual environment again, simply call <code>source &lt;path-to-venv&gt;/bin/activate</code> again.</p> <pre><code>pip install gapper~=1.3.0\n</code></pre>"},{"location":"Tutorials/Getting-Started/#create-autograder","title":"Create Autograder","text":"<p>Suppose you are creating a autograder for the following Python solution:</p> <pre><code># print_digits.py\ndef print_digits(n: int) -&gt; None:\n    print(n % 10)\n    if n &gt;= 10:\n        print_digits(n // 10)\n</code></pre> <p>First, you need to install <code>gapper</code> by running <code>pip install gapper~=1.3.0</code> in your terminal (the minimal Python version is 3.12.0). Once it's installed, you can import <code>problem</code> from <code>gapper</code> and invoke it as a decorator, like the following. This will transform the solution into a problem operated by the autograder. The <code>check_stdout</code> flag instructs the autograder to check <code>stdout</code> output from the <code>print</code> function. </p> <pre><code># print_digits.py\nfrom gapper import problem\n\n@problem(check_stdout=True)\ndef print_digits(n: int) -&gt; None:\n    print(n % 10)\n    if n &gt;= 10:\n        print_digits(n // 10)\n</code></pre> <p>Suppose you want to create 10 tests, each worth 1 point. In addition, 4 of them are hand written and others are randomly generated. You can import <code>test_case</code> and <code>test_cases</code> from <code>gapper</code>, and invoke them as you do with the <code>problem</code> directive. The following is an example. </p> <pre><code># print_digits.py\nfrom gapper import problem, test_case, test_cases\nimport random\n\n\n@test_cases.param_iter(\n    ([random.randint(100, 10000)] for _ in range(3)), gap_max_score=1, gap_hidden=True\n)\n@test_cases.param_iter(\n    ([random.randint(100, 10000)] for _ in range(3)), gap_max_score=1\n)\n@test_case(1, gap_max_score=1)\n@test_case(1234, gap_max_score=1)\n@test_case(3731, gap_max_score=1)\n@test_case(7, gap_max_score=1)\n@problem(check_stdout=True)\ndef print_digits(n: int) -&gt; None:\n    print(n % 10)\n    if n &gt;= 10:\n        print_digits(n // 10)\n</code></pre> <p>You can then in the command line invoke <code>gapper gen print_digits.py</code>, which will generate a <code>print_digits.zip</code> file. Note that, the random numbers are generated during creation time instead judging time, meaning once the autograder is created, the random numbers are chosen and fixed for all student submissions. </p> <p>You can upload manually to gradescope using the following steps. If you want to save this extra step, you can use the upload functionality provided by  <code>gapper</code>. Please see this section for more information.</p> <p>On gradescope, when creating a new assignment, choose <code>Programming Assignment</code> and fill in the required details. </p> <p></p> <p>Then, on the <code>configure autograder</code> page, click <code>Select Autograder (.zip)</code> button, choose the <code>print_digits.zip</code> file from your filesystem, and the click <code>Update Autograder</code>.</p> <p></p> <p>After the autograder is built, you can click on <code>Test Autograder</code> next to the <code>Update Autograder</code> button, and upload the <code>print_digits.py</code> solution to see the grading result. </p> <p></p>"},{"location":"Tutorials/Test-Result-%28Proxy%29/","title":"<code>TestResult</code> (Proxy)","text":"<p>We discuss how to operate the result proxy when overriding a test or writing custom post check functions. We recommend reading the <code>gap_override_test</code> and <code>gap_post_checks</code> sections first. </p>"},{"location":"Tutorials/Test-Result-%28Proxy%29/#structure-of-testresultproxy","title":"Structure of <code>TestResult</code>(Proxy)","text":"<p>A <code>TestResult</code> contains information of the execution result of a test. Thus, when creating your own testing functions or post checking functions, you might want to modify the test result object accordingly to store information such as score obtained, pass status, descriptions of the test, etc. In the text below, we will use test result proxy and test result interchangeably. </p> <pre><code>@dataclass\nclass TestResult:\n    default_name: str\n    name: str | None = None\n    score: float | None = field(default=None)\n    max_score: float | None = field(default=None)\n    weight: int | None = field(default=None)\n    extra_points: float | None = field(default=None)\n    errors: List[ErrorFormatter] = field(default_factory=list)\n    pass_status: PassStateType | None = field(default=None)\n    hidden: bool = False\n    descriptions: List[str] = field(default_factory=list)\n</code></pre>"},{"location":"Tutorials/Test-Result-%28Proxy%29/#usage","title":"Usage","text":"<p>The functions to <code>gap_override_test</code>, <code>gap_post_hooks</code>, <code>gap_pre_hooks</code>, <code>pre_tests</code> and <code>post_tests</code> all need an input of <code>TestResult</code> type. See this page for their signatures. </p> <p>You can set the result attributes using <code>set_&lt;attribute&gt;()</code> function. For example, </p> <pre><code>result_proxy.set_score(result_proxy.max_score // 2)\nresult_proxy.set_pass_status(\"failed\")\nresult_proxy.add_description(\n    \"Failed because recursive call not found in submission.\"\n)\n</code></pre> <p>Please refer to the API reference here for detailed usages. </p>"},{"location":"Tutorials/Upload-Autograder/","title":"Upload Autograder","text":"<p>There are two ways to upload your autograder directly to gradescope: through GUI, or through either a url to the assignment or the specific course id and assignment id.</p>"},{"location":"Tutorials/Upload-Autograder/#prerequisite","title":"Prerequisite","text":"<p>You need to understand what a course is and what an assignment is in gradescope, and the difference between the two.</p> What is a course? <p>A course is what you would see when you first log into gradescope. A course is usually listed as cards, and is under a specific year and term, e.g. Fall 2023. </p> What is an assignment? <p>An assignment is what you would see when you click on a course. An assignment is listed as a list.</p> <p>Before uploading, you are assumed to have your gradescope email and password, and have created the assignment you're uploading the autograder to. </p>"},{"location":"Tutorials/Upload-Autograder/#steps","title":"Steps","text":""},{"location":"Tutorials/Upload-Autograder/#login","title":"Login","text":"<p>To upload an autograder, you will need to log into your account. You can do that using the <code>gapper login</code> command. You can always check the commands' help messages by running <code>gapper &lt;command&gt; --help</code>.</p> <p>Note that, we don't store your password anywhere. However, we do remember your session cookie for upload to happen. If you find your cookies expired, simply log in again.</p>"},{"location":"Tutorials/Upload-Autograder/#upload","title":"Upload","text":"<p>Once you are logged in, you can use either of the following two ways to upload your autograder. </p>"},{"location":"Tutorials/Upload-Autograder/#upload-when-using-gapper-gen","title":"Upload when using <code>gapper gen</code>","text":"<p>When you're generating an autograder using <code>gapper gen</code>, simply by attaching <code>--upload</code> flag or <code>--upload --gui</code> to the command. </p>"},{"location":"Tutorials/Upload-Autograder/#-upload-flag-with-gs_connect","title":"<code>--upload</code> flag with <code>gs_connect</code>","text":"<p>If you're using <code>--upload</code> flag only, you have to have <code>gs_connect</code> decorator on your problem definition. </p> <p>When specifying <code>gs_connect</code> argument, you can either pass in a url to the assignment, or the course id and assignment id.</p> <p>An example using the url to the assignment: <pre><code>from gapper import problem, gs_connect\n\n@gs_connect('https://www.gradescope.com/courses/&lt;cid&gt;/assignments/&lt;aid&gt;')\n@problem()\ndef add(a: int, b: int) -&gt; int:\n    ...\n</code></pre></p> <p>Note that the url has to have at least contain <code>https://www.gradescope.com/courses/&lt;cid&gt;/assignments/&lt;aid&gt;</code>. It doesn't matter if there are any other things after the url. For example, <code>https://www.gradescope.com/courses/&lt;cid&gt;/assignments/&lt;aid&gt;/review_grades</code> is also acceptable. </p> <p>An example using the course id and assignment id: <pre><code>from gapper import problem, gs_connect\n\n@gs_connect('&lt;cid&gt;', '&lt;aid&gt;')\n@problem()\ndef add(a: int, b: int) -&gt; int:\n    ...\n</code></pre></p> <p>The <code>&lt;cid&gt;</code> and <code>&lt;aid&gt;</code> must be strings of digits. You can reference the API for more information. </p>"},{"location":"Tutorials/Upload-Autograder/#-upload-gui-flag-with-gui","title":"<code>--upload --gui</code> flag with GUI","text":"<p>If you don't specify <code>gs_connect</code>, you can add an additional <code>--gui</code> flag to use graphical interface to upload to an assignment. Simply type <code>gapper gen &lt;script&gt; --upload --gui</code> and follow the instruction. </p>"},{"location":"Tutorials/Upload-Autograder/#upload-a-zip-file","title":"Upload a zip file","text":"<p>If you have your autograder zip file already, you can use <code>gapper upload</code> command to upload your autograder.</p> <p>There are three subcommands under <code>gapper upload</code>: <code>gapper upload gui</code>, <code>gapper upload url</code>, and <code>gapper upload id</code>.</p>"},{"location":"Tutorials/Upload-Autograder/#gapper-upload-gui","title":"<code>gapper upload gui</code>","text":"<p>This command will open a graphical interface for you to upload your autograder. Simply type <code>gapper upload gui</code> and follow the instruction.</p>"},{"location":"Tutorials/Upload-Autograder/#gapper-upload-url","title":"<code>gapper upload url</code>","text":"<p>This command will upload your autograder to an assignment using the url to the assignment. Simply type <code>gapper upload url</code> and follow the instruction.</p>"},{"location":"Tutorials/Upload-Autograder/#gapper-upload-id","title":"<code>gapper upload id</code>","text":"<p>This command will upload your autograder to an assignment using the course id and assignment id. Simply type <code>gapper upload id</code> and follow the instruction.</p>"},{"location":"Tutorials/Upload-Autograder/#showcase","title":"Showcase","text":""},{"location":"Tutorials/Upload-Autograder/#fresh-start","title":"Fresh Start","text":""},{"location":"Tutorials/Upload-Autograder/#upload-with-gui","title":"Upload with GUI","text":""},{"location":"Tutorials/Upload-Autograder/#create-an-assignment-while-uploading","title":"Create An Assignment While Uploading","text":""},{"location":"Tutorials/Various-Function-Protocols/","title":"Various Function Protocols","text":"<p>It can be confusing to remember all function protocols used in gapper. Below, we list the function signatures and their docstrings for each use case.</p>"},{"location":"Tutorials/Various-Function-Protocols/#gap_override_test","title":"<code>gap_override_test</code>","text":""},{"location":"Tutorials/Various-Function-Protocols/#gapper.core.types.CustomTestFn","title":"CustomTestFn","text":"<p>             Bases: <code>Protocol</code></p> <p>The function type to be called for custom tests.</p> Source code in <code>src/gapper/core/types.py</code> <pre><code>class CustomTestFn(Protocol):\n    \"\"\"The function type to be called for custom tests.\"\"\"\n\n    def __call__[T](self, data: CustomTestData[T]) -&gt; None:\n        \"\"\"Implement.\n\n        :param data: The CustomTestData instance.\n        :raises AssertionError: It should raise assertion error if test fails.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"Tutorials/Various-Function-Protocols/#gapper.core.types.CustomTestFn.__call__","title":"__call__","text":"<pre><code>__call__(data: CustomTestData[T]) -&gt; None\n</code></pre> <p>Implement.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>CustomTestData[T]</code> <p>The CustomTestData instance.</p> required <p>Raises:</p> Type Description <code>AssertionError</code> <p>It should raise assertion error if test fails.</p> Source code in <code>src/gapper/core/types.py</code> <pre><code>def __call__[T](self, data: CustomTestData[T]) -&gt; None:\n    \"\"\"Implement.\n\n    :param data: The CustomTestData instance.\n    :raises AssertionError: It should raise assertion error if test fails.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"Tutorials/Various-Function-Protocols/#gapper.core.types.CustomTestData","title":"CustomTestData  <code>dataclass</code>","text":"<p>             Bases: <code>_TCMixin</code>, <code>_SolSubMixin[T]</code></p> Source code in <code>src/gapper/core/types.py</code> <pre><code>@dataclass\nclass CustomTestData[T](_TCMixin, _SolSubMixin[T]):\n    case: TestCaseWrapper\n    result_proxy: TestResult\n    solution: T\n    submission: T\n</code></pre>"},{"location":"Tutorials/Various-Function-Protocols/#gap_override_check","title":"<code>gap_override_check</code>","text":""},{"location":"Tutorials/Various-Function-Protocols/#gapper.core.types.CustomEqualityCheckFn","title":"CustomEqualityCheckFn","text":"<p>             Bases: <code>Protocol</code></p> <p>The function type to be called for custom equality checks.</p> Source code in <code>src/gapper/core/types.py</code> <pre><code>class CustomEqualityCheckFn(Protocol):\n    \"\"\"The function type to be called for custom equality checks.\"\"\"\n\n    def __call__[T](self, data: CustomEqualityTestData[T]) -&gt; None:\n        \"\"\"Implement.\n\n        :param data: The CustomEqualityTestData instance.\n        :raises AssertionError: It should raise assertion error if the equality check tails\n        \"\"\"\n        ...\n</code></pre>"},{"location":"Tutorials/Various-Function-Protocols/#gapper.core.types.CustomEqualityCheckFn.__call__","title":"__call__","text":"<pre><code>__call__(data: CustomEqualityTestData[T]) -&gt; None\n</code></pre> <p>Implement.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>CustomEqualityTestData[T]</code> <p>The CustomEqualityTestData instance.</p> required <p>Raises:</p> Type Description <code>AssertionError</code> <p>It should raise assertion error if the equality check tails</p> Source code in <code>src/gapper/core/types.py</code> <pre><code>def __call__[T](self, data: CustomEqualityTestData[T]) -&gt; None:\n    \"\"\"Implement.\n\n    :param data: The CustomEqualityTestData instance.\n    :raises AssertionError: It should raise assertion error if the equality check tails\n    \"\"\"\n    ...\n</code></pre>"},{"location":"Tutorials/Various-Function-Protocols/#gapper.core.types.CustomEqualityTestData","title":"CustomEqualityTestData  <code>dataclass</code>","text":"Source code in <code>src/gapper/core/types.py</code> <pre><code>@dataclass\nclass CustomEqualityTestData[T]:\n    expected: T\n    actual: T\n    msg: str | None = field(default=None)\n</code></pre>"},{"location":"Tutorials/Various-Function-Protocols/#gap_pre_hook","title":"<code>gap_pre_hook</code>","text":""},{"location":"Tutorials/Various-Function-Protocols/#gapper.core.types.PreHookFn","title":"PreHookFn","text":"<p>             Bases: <code>Protocol</code></p> <p>The function type to be called for post checks all the equality check of a test case.</p> Source code in <code>src/gapper/core/types.py</code> <pre><code>class PreHookFn(Protocol):\n    \"\"\"The function type to be called for post checks all the equality check of a test case.\"\"\"\n\n    def __call__[T](self, data: PreHookData[T]) -&gt; None:\n        \"\"\"Implement.\n\n        :param data: The PreTestHookData instance.\n        :raises AssertionError: It should raise assertion error if the pre hook fails.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"Tutorials/Various-Function-Protocols/#gapper.core.types.PreHookFn.__call__","title":"__call__","text":"<pre><code>__call__(data: PreHookData[T]) -&gt; None\n</code></pre> <p>Implement.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>PreHookData[T]</code> <p>The PreTestHookData instance.</p> required <p>Raises:</p> Type Description <code>AssertionError</code> <p>It should raise assertion error if the pre hook fails.</p> Source code in <code>src/gapper/core/types.py</code> <pre><code>def __call__[T](self, data: PreHookData[T]) -&gt; None:\n    \"\"\"Implement.\n\n    :param data: The PreTestHookData instance.\n    :raises AssertionError: It should raise assertion error if the pre hook fails.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"Tutorials/Various-Function-Protocols/#gapper.core.types.PreHookData","title":"PreHookData  <code>dataclass</code>","text":"<p>             Bases: <code>HookDataBase</code>, <code>_TCMixin</code>, <code>_SolSubMixin[T]</code></p> Source code in <code>src/gapper/core/types.py</code> <pre><code>@dataclass\nclass PreHookData[T](HookDataBase, _TCMixin, _SolSubMixin[T]):\n    case: TestCaseWrapper\n    result_proxy: TestResult\n    solution: T\n    submission: T\n</code></pre>"},{"location":"Tutorials/Various-Function-Protocols/#gap_post_hook","title":"<code>gap_post_hook</code>","text":""},{"location":"Tutorials/Various-Function-Protocols/#gapper.core.types.PostHookFn","title":"PostHookFn","text":"<p>             Bases: <code>Protocol</code></p> <p>The function type to be called for post checks all the equality check of a test case.</p> Source code in <code>src/gapper/core/types.py</code> <pre><code>class PostHookFn(Protocol):\n    \"\"\"The function type to be called for post checks all the equality check of a test case.\"\"\"\n\n    def __call__[T](self, data: PostHookData[T]) -&gt; None:\n        \"\"\"Implement.\n\n        :param data: The PostTestHookData instance.\n        :raises AssertionError: It should raise assertion error if the post hook fails.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"Tutorials/Various-Function-Protocols/#gapper.core.types.PostHookFn.__call__","title":"__call__","text":"<pre><code>__call__(data: PostHookData[T]) -&gt; None\n</code></pre> <p>Implement.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>PostHookData[T]</code> <p>The PostTestHookData instance.</p> required <p>Raises:</p> Type Description <code>AssertionError</code> <p>It should raise assertion error if the post hook fails.</p> Source code in <code>src/gapper/core/types.py</code> <pre><code>def __call__[T](self, data: PostHookData[T]) -&gt; None:\n    \"\"\"Implement.\n\n    :param data: The PostTestHookData instance.\n    :raises AssertionError: It should raise assertion error if the post hook fails.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"Tutorials/Various-Function-Protocols/#gapper.core.types.PostHookData","title":"PostHookData  <code>dataclass</code>","text":"<p>             Bases: <code>HookDataBase</code>, <code>_TCMixin</code>, <code>_SolSubMixin[T]</code>, <code>_SolSubResultMixin[T]</code></p> Source code in <code>src/gapper/core/types.py</code> <pre><code>@dataclass\nclass PostHookData[T](HookDataBase, _TCMixin, _SolSubMixin[T], _SolSubResultMixin[T]):\n    case: TestCaseWrapper\n    result_proxy: TestResult\n    solution: T\n    submission: T\n    expected_results: ResultBundle\n    actual_results: ResultBundle\n</code></pre>"},{"location":"Tutorials/Various-Function-Protocols/#pre_tests","title":"<code>pre_tests</code>","text":""},{"location":"Tutorials/Various-Function-Protocols/#gapper.core.types.PreTestsFn","title":"PreTestsFn","text":"<p>             Bases: <code>Protocol</code></p> Source code in <code>src/gapper/core/types.py</code> <pre><code>class PreTestsFn(Protocol):\n    def __call__(self, data: PreTestsData) -&gt; None:\n        \"\"\"Implement.\n\n        :param data: The PreTestsData instance.\n        :raises AssertionError: It should raise assertion error if the pre tests hook fail.\n        \"\"\"\n</code></pre>"},{"location":"Tutorials/Various-Function-Protocols/#gapper.core.types.PreTestsFn.__call__","title":"__call__","text":"<pre><code>__call__(data: PreTestsData) -&gt; None\n</code></pre> <p>Implement.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>PreTestsData</code> <p>The PreTestsData instance.</p> required <p>Raises:</p> Type Description <code>AssertionError</code> <p>It should raise assertion error if the pre tests hook fail.</p> Source code in <code>src/gapper/core/types.py</code> <pre><code>def __call__(self, data: PreTestsData) -&gt; None:\n    \"\"\"Implement.\n\n    :param data: The PreTestsData instance.\n    :raises AssertionError: It should raise assertion error if the pre tests hook fail.\n    \"\"\"\n</code></pre>"},{"location":"Tutorials/Various-Function-Protocols/#gapper.core.types.PreTestsData","title":"PreTestsData  <code>dataclass</code>","text":"<p>             Bases: <code>HookDataBase</code></p> Source code in <code>src/gapper/core/types.py</code> <pre><code>@dataclass\nclass PreTestsData[T](HookDataBase):\n    result_proxy: TestResult | None = field(default=None)\n    metadata: GradescopeSubmissionMetadata | None = field(default=None)\n</code></pre>"},{"location":"Tutorials/Various-Function-Protocols/#post_tests","title":"<code>post_tests</code>","text":""},{"location":"Tutorials/Various-Function-Protocols/#gapper.core.types.PostTestsFn","title":"PostTestsFn","text":"<p>             Bases: <code>Protocol</code></p> <p>The function type to be called after all tests are run.</p> Source code in <code>src/gapper/core/types.py</code> <pre><code>class PostTestsFn(Protocol):\n    \"\"\"The function type to be called after all tests are run.\"\"\"\n\n    def __call__(self, data: PostTestsData) -&gt; None:\n        \"\"\"Implement.\n\n        :param data: The PostTestsData instance.\n        :raises AssertionError: It should raise assertion error if the post tests hook fail.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"Tutorials/Various-Function-Protocols/#gapper.core.types.PostTestsFn.__call__","title":"__call__","text":"<pre><code>__call__(data: PostTestsData) -&gt; None\n</code></pre> <p>Implement.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>PostTestsData</code> <p>The PostTestsData instance.</p> required <p>Raises:</p> Type Description <code>AssertionError</code> <p>It should raise assertion error if the post tests hook fail.</p> Source code in <code>src/gapper/core/types.py</code> <pre><code>def __call__(self, data: PostTestsData) -&gt; None:\n    \"\"\"Implement.\n\n    :param data: The PostTestsData instance.\n    :raises AssertionError: It should raise assertion error if the post tests hook fail.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"Tutorials/Various-Function-Protocols/#gapper.core.types.PostTestsData","title":"PostTestsData  <code>dataclass</code>","text":"<p>             Bases: <code>HookDataBase</code></p> Source code in <code>src/gapper/core/types.py</code> <pre><code>@dataclass\nclass PostTestsData[T](HookDataBase):\n    test_results: List[TestResult]\n    result_proxy: TestResult | None = field(default=None)\n    metadata: GradescopeSubmissionMetadata | None = field(default=None)\n</code></pre>"},{"location":"Tutorials/gap_-Keywords/","title":"<code>gap_</code> Keywords","text":"<p>This post discusses the effect of each <code>gap_</code> keyword and how they can be used. </p>"},{"location":"Tutorials/gap_-Keywords/#gap_-keyword-listing","title":"<code>gap_</code> Keyword Listing","text":"<p>We list the possible <code>gap_</code> keywords below. </p> <pre><code>gap_expect: The expected output of the test case.\ngap_expect_stdout: The expected stdout of the test case.\ngap_hidden: Whether the test case is hidden.\ngap_name: The name of the test case.\ngap_extra_points: The extra credit of the test case.\ngap_override_check: The custom equality check function.\ngap_easy_context: Whether to use context directly in gap override tests.\ngap_override_test: The custom test function.\ngap_pre_hooks: The custom functions run before tests.\ngap_post_hooks: The custom functions run after tests.\ngap_description: The description of the test case.\ngap_is_pipeline: Whether the test case is a pipeline.\ngap_max_score: The max score of the test case. This and gap_weight cannot be specified as the same time. \ngap_weight: The weight of the test case. This and gap_max_score cannot be specified as the same time. .\n</code></pre>"},{"location":"Tutorials/gap_-Keywords/#how-to-specify-them-in-test_case-and-test_cases","title":"How To Specify Them In <code>@test_case()</code> And <code>@test_cases</code>","text":"<ul> <li>In <code>@test_case()</code>, <code>gap_</code> keywords are specified as ordinary keyword arguments. For example, <code>@test_case(1, 2, gap_expect=3, gap_name=\"secret test\", gap_max_score=5)</code>. </li> <li>In <code>@test_cases()</code>, <code>gap_</code> keywords are also specified as keyword arguments but accept one single value or a <code>Sequence</code> of values. For example, <code>@test_cases.params([1,2], [3,4], gap_max_score=2, gap_name=[\"test 1\", \"test 2\"])</code>. When a single value is passed, it will be duplicated to every test cases. When a sequence is passed, the length of the sequence has to be the same as the number of test cases, and will be applied to each test case in order. </li> </ul>"},{"location":"Tutorials/gap_-Keywords/#gap_expect","title":"<code>gap_expect</code>","text":"<p>This serves as sanity check to the correctness of the defined problem. When specified in a test case, it's value equals the expected outcome of executing the test case. For example, </p> <pre><code># add_num.py\n@test_case(2, 2, gap_expect=3)\n@test_case(1, 2, gap_expect=3)\n@problem()\ndef add(a: int, b: int) -&gt; int:\n    return a + b\n</code></pre> <p>Using the command line, we invoke <code>gapper check add_num.py</code> ad we will see </p> <pre><code>\u276f gapper check add_num.py\nTest (1, 2) passed: True\nTest (2, 2) passed: False\n  result: 4\n  expected result: 3\n  output: None\n  expected output: None\n</code></pre>"},{"location":"Tutorials/gap_-Keywords/#gap_expect_stdout","title":"<code>gap_expect_stdout</code>","text":"<p>It is similar to <code>gap_expect</code> except it expects output from the <code>stdout</code>. </p>"},{"location":"Tutorials/gap_-Keywords/#gap_hidden","title":"<code>gap_hidden</code>","text":"<p>It accepts <code>True</code> or <code>False</code> and indicates if the test case can be seen by student. For example, </p> <p><pre><code>@test_cases.param_iter(\n    ([random.randint(100, 10000)] for _ in range(3)),\n    gap_max_score=2,\n    gap_hidden=True,\n    gap_name=\"random hidden tests\",\n)\n</code></pre>  will make the entries not shown to students at all (but still visible from instructor/TA's panel)</p> <p></p>"},{"location":"Tutorials/gap_-Keywords/#gap_name","title":"<code>gap_name</code>","text":"<p>A custom name of the autograder beside showing the argument passed to the test. For example, </p> <pre><code>@test_cases.param_iter(\n    ([random.randint(100, 10000)] for _ in range(3)),\n    gap_max_score=2,\n    gap_hidden=True,\n    gap_name=\"random hidden tests\",\n)\n@test_cases.param_iter(\n    ([random.randint(100, 10000)] for _ in range(3)),\n    gap_max_score=0,\n    gap_name=\"random tests\",\n)\n</code></pre> <p>will produce </p> <p></p>"},{"location":"Tutorials/gap_-Keywords/#gap_description","title":"<code>gap_description</code>","text":"<p>Description of the test that will be shown to the students. For example, the following code will produce the result below. </p> <pre><code>@test_case(\n    1, gap_max_score=1, gap_description=\"this is the test in the assignment handout\"\n)\n@test_case(1234, gap_max_score=1, gap_description=[\"this test is \", \"slightly longer\"])\n</code></pre> <p></p>"},{"location":"Tutorials/gap_-Keywords/#gap_max_score","title":"<code>gap_max_score</code>","text":"<p>The max score this test is worth. This cannot coexist with <code>gap_weight</code>. </p>"},{"location":"Tutorials/gap_-Keywords/#gap_weight","title":"<code>gap_weight</code>","text":"<p>The weight of the max score this test is worth. This cannot coexist with <code>gap_max_score</code>. The calculation of the max score is </p> <pre><code>max_score_of_the_test = gap_weight * (totoal_score_of_the_assignment - sum(gap_max_score in all tests)) / sum(gap_weight in all tests) \n</code></pre> <p>If both <code>gap_weight</code> and <code>gap_max_score</code> are not set, the test case will be assigned with a default weight of <code>1</code>. </p> <p>For example, suppose we create 4 test cases worth total 4 points. </p> <pre><code>@test_case(1, gap_description=\"this is the test in the assignment handout\")\n@test_case(1234, gap_weight=2, gap_description=[\"this test is \", \"slightly longer\"])\n@test_case(3731, gap_weight=4)\n@test_case(7)\n</code></pre> <p>will produce the following max score assignment </p> <p></p> <p>because, for the test case of <code>(1,)</code> and case of <code>(7,)</code>, the score is calculated as </p> <pre><code>1 * (4 - 0) / (1 + 2 + 4 + 1) = 4 / 8 = 0.5\n</code></pre> <p>and similarly, the score assigned for the case of <code>(1234,)</code> is from </p> <pre><code>2 * (4 - 0) / (1 + 2 + 4 + 1) = 8 / 8 = 1\n</code></pre>"},{"location":"Tutorials/gap_-Keywords/#gap_extra_points","title":"<code>gap_extra_points</code>","text":"<p>Extra points specified in a test is a number and will be granted to student if they passed to test. For example, </p> <pre><code>@test_case(random.randint(100000, 1000000), gap_max_score=0, gap_extra_points=5)\n</code></pre> <p>will result in 5 extra points when the student passes the test, shown as following: </p> <p></p>"},{"location":"Tutorials/gap_-Keywords/#gap_override_check","title":"<code>gap_override_check</code>","text":"<p>You can override tests' equality checks by passing a comparator function to <code>gap_override_check</code> keyword. The  function should raise an <code>AssertionError</code> if the two values are not equal. </p> <p>For example, suppose that you want to compare answers from students' submissions with the solution but do not care about ordering, you can pass  <code>gap_override_check=set_equality</code> to <code>@test_case()</code> where <code>set_equality</code> is pre-defined in your script as </p> <pre><code>from gapper.core.types import CustomEqualityTestData\n\n\ndef set_equality(data: CustomEqualityTestData) -&gt; None:\n    assert set(data.expected) == set(data.actual)\n</code></pre>"},{"location":"Tutorials/gap_-Keywords/#gap_override_test","title":"<code>gap_override_test</code>","text":"<p>You can override entire test by passing a custom function to <code>gap_override_test</code> parameter, similar to override equality checks. For example, you not only want to check the answers, but also ensure the function is recursive. You can define <code>custom_test</code> as the following and pass it as <code>gap_override_test=custom_test</code> in your <code>@test_case()</code>. Note that you have to run the test and equality check by yourself, for the entire test process is overridden.</p> <pre><code>import ast\nimport inspect\nfrom gapper import problem, test_case\nfrom gapper.core.types import CustomTestData\n\nfrom pytest import approx\n\n\ndef check_recursive_ast(fn):\n    tree = ast.parse(inspect.getsource(fn))\n    for node in ast.walk(tree):\n        if isinstance(node, ast.Call):\n            if isinstance(node.func, ast.Name):\n                if node.func.id == fn.__name__:\n                    return True\n    return False\n\n\ndef custom_test(data: CustomTestData) -&gt; None:\n    soln_ans = data.solution(*data.args, **data.kwargs)\n    subm_ans = data.submission(*data.args, **data.kwargs)\n\n    data.case.assertEqual(soln_ans, subm_ans)  # equivalent to `assert soln_ans == subm_ans`\n\n    # param.assertTrue(check_recursive_ast(submission))\n    # equivalent to `assert check_recursive_ast(submission)`\n\n    # you can even use pytest helper functions\n    # the following line is dumb but just for demonstration\n    assert soln_ans == approx(subm_ans, rel=1e-3)\n\n    if not check_recursive_ast(data.submission):\n        data.result_proxy.set_score(data.result_proxy.max_score // 2)\n\n\n@test_case(10, gap_override_test=custom_test)\n@problem()\ndef fib(n: int) -&gt; int:\n    ...\n</code></pre> <p>A overriding function show have the following positional parameter signature </p> <pre><code>from gapper.core.types import CustomTestData\n\nclass CustomTestFn(Protocol):\n    def __call__[T](self, data: CustomTestData[T]) -&gt; None:\n        ...\n</code></pre>"},{"location":"Tutorials/gap_-Keywords/#gap_pre_hooks","title":"<code>gap_pre_hooks</code>","text":"<p><code>gap_post_hooks</code> are function(s) run before running the the student's answer and the solution.</p> <p>You can setup the environment or use it to modify the test case before. For example,</p> <pre><code>from gapper import problem, test_case\nfrom gapper.core.types import PreHookData\nfrom tempfile import NamedTemporaryFile\n\n\ndef preparation(data: PreHookData) -&gt; None:\n    lines = data.args[0]\n    # put lines into a temporary file\n    with NamedTemporaryFile(\"w\", delete=False) as infile:\n        infile.write(\"\\n\".join(lines))\n\n    # set the args to the filename passed the student's function\n    data.param.args = (infile.name,)\n\n\ndef gen_lines(num_of_lines: int) -&gt; list[str]:\n    return [str(i) for i in range(num_of_lines)]\n\n\n@test_case(gen_lines(10), gap_pre_hooks=preparation)\n@problem()\ndef print_lines(filename: str) -&gt; int:\n    with open(filename, \"r\") as f:\n        return sum(map(lambda line: int(line.strip()), f.readlines()), 0)\n</code></pre> <p>Note that, the <code>preparation</code> function should have a tear down phase to clean up the temporary file created, since the code above sets the automatic deletion to <code>False</code>.  The hooks support yield syntax, which nicely separate a hook into two phases, setup and tear down. For example,  the function <code>preparation</code> can be rewritten as </p> <pre><code>from typing import Generator\nfrom tempfile import NamedTemporaryFile\nfrom gapper.core.types import PreHookData\n\n\ndef preparation(data: PreHookData) -&gt; Generator[None, None, None]:\n    lines = data.args[0]\n    # put lines into a temporary file\n    with NamedTemporaryFile(\"w\") as infile:\n        infile.write(\"\\n\".join(lines))\n        data.param.args = (infile.name,)\n\n        # everything above yield will be run before the test case is tested\n        yield \n        # everything below yield will be run after all tests of the test case are done\n        # this means the code exists the with statement after testing the test case\n        # on which the temporary file can be safely deleted\n</code></pre> <p>A pre hook function has to follow the following positional parameter signature</p> <pre><code>from gapper.core.types import PreHookData\n\nclass PostHookFn(Protocol):\n    def __call__[T](self, data: PreHookData[T]) -&gt; None:\n        ...\n</code></pre>"},{"location":"Tutorials/gap_-Keywords/#gap_post_hooks","title":"<code>gap_post_hooks</code>","text":"<p><code>gap_post_hooks</code> are function(s) run after running the student's answer and the solution, and comparing the results and stdout of the two.</p> <p>Consider the situation in which you'd like to provide extra checks but not override the whole test. You can write custom check functions and pass it into <code>gap_post_checks</code>. For example, you'd like to check if the students' solutions are recursive, you can write</p> <pre><code>from gapper import problem, test_case\nfrom gapper.core.types import PostHookData\n\nimport ast \nimport inspect\n\n\ndef check_recursive_ast(fn):\n    tree = ast.parse(inspect.getsource(fn))\n    for node in ast.walk(tree):\n        if isinstance(node, ast.Call):\n            if isinstance(node.func, ast.Name):\n                if node.func.id == fn.__name__:\n                    return True\n    return False\n\n\ndef recursive_check(data: PostHookData) -&gt; None:\n    if not check_recursive_ast(data.submission):\n        data.result_proxy.set_score(data.result_proxy.max_score // 2)\n        data.result_proxy.set_pass_status(\"failed\")\n        data.result_proxy.add_description(\n            \"Failed because recursive call not found in submission.\"\n        )\n\n\n@test_case(10, gap_post_hooks=recursive_check)\n@problem()\ndef fib(n: int) -&gt; int:\n    ...\n</code></pre> <p>A post hook function has to follow the following positional parameter signature</p> <pre><code>from gapper.core.types import PostHookData\n\nclass PostHookFn(Protocol):\n    def __call__[T](self, data: PostHookData[T]) -&gt; None:\n        ...\n</code></pre> <p>Note that post test hooks also support the yield syntax as stated in the <code>gap_pre_hooks</code> section. </p>"},{"location":"Tutorials/gap_-Keywords/#gap_pipeline","title":"<code>gap_pipeline</code>","text":"<p>The <code>gap_pipeline</code> keyword is invented to simulated a sequence of actions acting on an object. The object going into the pipeline might remain the same, be modified, or be swapped. It comes handy when testing classes and their instances' behaviors. For example, given a <code>Car</code> class, </p> <pre><code>class Car:\n    def __init__(self, x: int, y: int, tank_size: float) -&gt; None:\n        self.x = x\n        self.y = y\n        self.tank_size = tank_size\n        self.fuel = tank_size\n\n    def drive_to(self, x: int, y: int) -&gt; bool:\n        dis = abs(x - self.x) + abs(y - self.y)\n        if dis &gt; self.fuel:\n            return False\n        else:\n            self.fuel -= dis\n            self.x = x\n            self.y = y\n            return True\n\n    def refill(self) -&gt; None:\n        self.fuel = self.tank_size\n\n    def get_fuel(self) -&gt; float:\n        return self.fuel\n</code></pre> <p>Using pipeline, we can (1) test creating instances with different parameters, (2) running some functions of the instances and check if their outputs match, (3) and checking if attributes and states match (but we recommend requiring student to create uniform interfaces (functions) and not check the properties directly). </p> <pre><code>from gapper import problem, test_case\nfrom gapper.core.pipeline_support import Constructor, Function, Property\n\ninit = Constructor()\ndrive_to = Function(\"drive_to\")\nrefill = Function(\"refill\")\nget_fuel = Function(\"get_fuel\")\nx = Property(\"x\")\ny = Property(\"y\")\ntank_size = Property(\"tank_size\")\n\n\n@test_case.pipeline(   # using `@test_case.pipeline` is equivalent to `@test_case(gap_pipeline=True)`\n    init(0, 0, 100),\n    tank_size,         # we recommend creating a uniform interface such as `get_tank_size()`\n    x,                 # and not to check the attributes directly \n    y,\n    drive_to(10, 10),\n    get_fuel(),\n    drive_to(100, 0),\n    get_fuel(),\n    refill(),\n    drive_to(100, 0),\n    get_fuel(),\n)\n@problem()\nclass Car:\n    ...\n</code></pre>"},{"location":"Tutorials/gap_-Keywords/#example-script","title":"Example Script","text":"<pre><code>from gapper import problem, test_case, test_cases\nimport random\n\n\n@test_case(random.randint(100000, 1000000), gap_max_score=0, gap_extra_points=5)\n@test_cases.param_iter(\n    ([random.randint(100, 10000)] for _ in range(3)),\n    gap_max_score=2,\n    gap_hidden=True,\n    gap_name=\"random hidden tests\",\n)\n@test_cases.param_iter(\n    ([random.randint(100, 10000)] for _ in range(3)),\n    gap_max_score=0,\n    gap_name=\"random tests\",\n)\n@test_case(1, gap_description=\"this is the test in the assignment handout\")\n@test_case(1234, gap_weight=2, gap_description=[\"this test is \", \"slightly longer\"])\n@test_case(3731, gap_weight=4)\n@test_case(7)\n@problem(check_stdout=True)\ndef print_digits(n: int) -&gt; None:\n    print(n % 10)\n    if n &gt;= 10:\n        print_digits(n // 10)\n</code></pre>"}]}